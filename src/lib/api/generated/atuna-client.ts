/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Atuna API
 * A back-end for Atuna.
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AccountBan,
  AccountRejection,
  AddAgentToTeamTeamsTeamIdAgentsPost200,
  AddAgentToTeamTeamsTeamIdAgentsPostParams,
  AgentAccomplishmentsResponse,
  AgentCreate,
  AgentRegister,
  AgentResponse,
  BodyCreateAgentAgentsPost,
  BodyCreateBrokerBrokersPost,
  BodyCreateDeveloperDevelopersPost,
  BodyUploadPropertiesCsvPropertiesUploadCsvPost,
  BookmarkCreate,
  BookmarkResponse,
  BrokerCreate,
  BrokerRegister,
  BrokerResponse,
  CSVUploadResponse,
  CancelSiteViewingSiteViewingsViewingIdDelete200,
  ClientRegister,
  CreateMaintenanceRequestMaintenancePost200,
  CreateNotificationNotificationsPostParams,
  CreatePaymentMaintenancePaymentsPost200,
  CreateTeamTeamsPost200,
  DashboardAnalytics,
  DeveloperCreate,
  DeveloperRegister,
  DeveloperResponse,
  EventCreate,
  EventDetailResponse,
  EventResponse,
  EventUpdate,
  GetAdminsAdminsGetParams,
  GetAgentPerformanceAnalyticsAgentPerformanceGetParams,
  GetAgentsAgentsGetParams,
  GetApprovedAccountsAccountsApprovedGetParams,
  GetBannedAccountsAccountsBannedGetParams,
  GetBookmarksBookmarksGetParams,
  GetBrokersBrokersGetParams,
  GetClientsClientsGetParams,
  GetConversionFunnelAnalyticsConversionFunnelGetParams,
  GetDashboardAnalyticsTeamsAnalyticsDashboardGet200,
  GetDeletedAccountsAccountsDeletedGetParams,
  GetDevelopersDevelopersGetParams,
  GetInventoryAnalyticsAnalyticsInventoryGetParams,
  GetInventoryAnalyticsTeamsAnalyticsInventoryGet200,
  GetLeadsAnalyticsAnalyticsLeadsGetParams,
  GetLeadsAnalyticsTeamsAnalyticsLeadsGet200,
  GetLeadsAnalyticsTeamsAnalyticsLeadsGetParams,
  GetLeadsSiteViewingsCrmLeadsGetParams,
  GetMaintenanceRequestMaintenanceRequestIdGet200,
  GetMaintenanceRequestsMaintenanceGet200Item,
  GetMaintenanceRequestsMaintenanceGetParams,
  GetMonthlyEventsEventsGetParams,
  GetNotificationsNotificationsGetParams,
  GetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet200,
  GetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet200,
  GetPaymentsMaintenancePaymentsGet200Item,
  GetPaymentsMaintenancePaymentsGetParams,
  GetPendingAccountsAccountsPendingGetParams,
  GetPipelineSummarySiteViewingsCrmPipelineSummaryGet200,
  GetPipelineSummarySiteViewingsCrmPipelineSummaryGetParams,
  GetPropertiesPropertiesGetParams,
  GetPropertyPerformanceAnalyticsPropertyPerformanceGetParams,
  GetRejectedAccountsAccountsRejectedGetParams,
  GetRevenueAnalyticsAnalyticsRevenueGetParams,
  GetSalesAnalyticsAnalyticsSalesGetParams,
  GetSalesAnalyticsTeamsAnalyticsSalesGet200,
  GetSalesAnalyticsTeamsAnalyticsSalesGetParams,
  GetSiteViewingsSiteViewingsGetParams,
  GetTeamDetailsTeamsTeamIdGet200,
  GetTeamMembersTeamsTeamIdMembersGetParams,
  GetTeamsTeamsGet200Item,
  HTTPValidationError,
  InventoryAnalytics,
  LeadCreate,
  LeadResponse,
  LeadsAnalytics,
  MaintenanceRequestCreate,
  MaintenanceRequestUpdate,
  MarkAllNotificationsAsReadNotificationsPut200,
  NotificationCreate,
  NotificationResponse,
  PaginatedResponse,
  PaymentCreate,
  PropertyAssignmentCreate,
  PropertyAssignmentResponse,
  PropertyBulkCreate,
  PropertyCreate,
  PropertyResponse,
  PropertyUpdate,
  RemoveAgentFromTeamTeamsTeamIdAgentsAgentIdDelete200,
  SalesAnalytics,
  SiteViewingCreate,
  SiteViewingResponse,
  SiteViewingUpdate,
  TeamCreate,
  TeamMemberCreate,
  TeamMemberResponse,
  TeamResponse,
  TeamUpdate,
  Token,
  UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut200,
  UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutParams,
  UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutParams,
  UpdateMaintenanceRequestMaintenanceRequestIdPut200,
  UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPut200,
  UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutParams,
  UploadPropertiesCsvPropertiesUploadCsvPostParams,
  UserCreate,
  UserLogin,
  UserPendingResponse,
  UserResponse,
  UserUpdate,
} from "./model";

import { api } from "../http";
/**
 * Client (generic) signin endpoint.

Request body: UserLogin { email, password, role? (ignored here) }
Response: Token { access_token, token_type, user_id, role }

Important:
- `authenticate_user` is async → must be awaited.
 * @summary Signin For Access Token
 */
export const signinForAccessTokenAuthSigninPost = (
  userLogin: UserLogin,
  signal?: AbortSignal,
) => {
  return api<Token>({
    url: `https://api.atuna.org/auth/signin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userLogin,
    signal,
  });
};

export const getSigninForAccessTokenAuthSigninPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signinForAccessTokenAuthSigninPost>>,
    TError,
    { data: UserLogin },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signinForAccessTokenAuthSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationKey = ["signinForAccessTokenAuthSigninPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signinForAccessTokenAuthSigninPost>>,
    { data: UserLogin }
  > = (props) => {
    const { data } = props ?? {};

    return signinForAccessTokenAuthSigninPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SigninForAccessTokenAuthSigninPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof signinForAccessTokenAuthSigninPost>>
>;
export type SigninForAccessTokenAuthSigninPostMutationBody = UserLogin;
export type SigninForAccessTokenAuthSigninPostMutationError =
  HTTPValidationError;

/**
 * @summary Signin For Access Token
 */
export const useSigninForAccessTokenAuthSigninPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof signinForAccessTokenAuthSigninPost>>,
      TError,
      { data: UserLogin },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof signinForAccessTokenAuthSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationOptions =
    getSigninForAccessTokenAuthSigninPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Developer-specific signin endpoint.

Rules:
- Must be a user with role == "developer".
- Account must be office-verified (`is_verified`).
 * @summary Developer Signin
 */
export const developerSigninAuthDeveloperSigninPost = (
  userLogin: UserLogin,
  signal?: AbortSignal,
) => {
  return api<Token>({
    url: `https://api.atuna.org/auth/developer/signin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userLogin,
    signal,
  });
};

export const getDeveloperSigninAuthDeveloperSigninPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof developerSigninAuthDeveloperSigninPost>>,
    TError,
    { data: UserLogin },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof developerSigninAuthDeveloperSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationKey = ["developerSigninAuthDeveloperSigninPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof developerSigninAuthDeveloperSigninPost>>,
    { data: UserLogin }
  > = (props) => {
    const { data } = props ?? {};

    return developerSigninAuthDeveloperSigninPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeveloperSigninAuthDeveloperSigninPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof developerSigninAuthDeveloperSigninPost>>
>;
export type DeveloperSigninAuthDeveloperSigninPostMutationBody = UserLogin;
export type DeveloperSigninAuthDeveloperSigninPostMutationError =
  HTTPValidationError;

/**
 * @summary Developer Signin
 */
export const useDeveloperSigninAuthDeveloperSigninPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof developerSigninAuthDeveloperSigninPost>>,
      TError,
      { data: UserLogin },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof developerSigninAuthDeveloperSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationOptions =
    getDeveloperSigninAuthDeveloperSigninPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Broker-specific signin endpoint.

Rules:
- Must be a user with role == "broker".
- Account must be office-verified (`is_verified`).
 * @summary Broker Signin
 */
export const brokerSigninAuthBrokerSigninPost = (
  userLogin: UserLogin,
  signal?: AbortSignal,
) => {
  return api<Token>({
    url: `https://api.atuna.org/auth/broker/signin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userLogin,
    signal,
  });
};

export const getBrokerSigninAuthBrokerSigninPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof brokerSigninAuthBrokerSigninPost>>,
    TError,
    { data: UserLogin },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof brokerSigninAuthBrokerSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationKey = ["brokerSigninAuthBrokerSigninPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof brokerSigninAuthBrokerSigninPost>>,
    { data: UserLogin }
  > = (props) => {
    const { data } = props ?? {};

    return brokerSigninAuthBrokerSigninPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BrokerSigninAuthBrokerSigninPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof brokerSigninAuthBrokerSigninPost>>
>;
export type BrokerSigninAuthBrokerSigninPostMutationBody = UserLogin;
export type BrokerSigninAuthBrokerSigninPostMutationError = HTTPValidationError;

/**
 * @summary Broker Signin
 */
export const useBrokerSigninAuthBrokerSigninPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof brokerSigninAuthBrokerSigninPost>>,
      TError,
      { data: UserLogin },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof brokerSigninAuthBrokerSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationOptions =
    getBrokerSigninAuthBrokerSigninPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Agent-specific signin endpoint.

Rules:
- Must be a user with role == "agent".
 * @summary Agent Signin
 */
export const agentSigninAuthAgentSigninPost = (
  userLogin: UserLogin,
  signal?: AbortSignal,
) => {
  return api<Token>({
    url: `https://api.atuna.org/auth/agent/signin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userLogin,
    signal,
  });
};

export const getAgentSigninAuthAgentSigninPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentSigninAuthAgentSigninPost>>,
    TError,
    { data: UserLogin },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentSigninAuthAgentSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationKey = ["agentSigninAuthAgentSigninPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentSigninAuthAgentSigninPost>>,
    { data: UserLogin }
  > = (props) => {
    const { data } = props ?? {};

    return agentSigninAuthAgentSigninPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentSigninAuthAgentSigninPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentSigninAuthAgentSigninPost>>
>;
export type AgentSigninAuthAgentSigninPostMutationBody = UserLogin;
export type AgentSigninAuthAgentSigninPostMutationError = HTTPValidationError;

/**
 * @summary Agent Signin
 */
export const useAgentSigninAuthAgentSigninPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentSigninAuthAgentSigninPost>>,
      TError,
      { data: UserLogin },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentSigninAuthAgentSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationOptions =
    getAgentSigninAuthAgentSigninPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Admin-specific signin endpoint.

Rules:
- Must be a user with role == "admin".
 * @summary Admin Signin
 */
export const adminSigninAuthAdminSigninPost = (
  userLogin: UserLogin,
  signal?: AbortSignal,
) => {
  return api<Token>({
    url: `https://api.atuna.org/auth/admin/signin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userLogin,
    signal,
  });
};

export const getAdminSigninAuthAdminSigninPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminSigninAuthAdminSigninPost>>,
    TError,
    { data: UserLogin },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminSigninAuthAdminSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationKey = ["adminSigninAuthAdminSigninPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminSigninAuthAdminSigninPost>>,
    { data: UserLogin }
  > = (props) => {
    const { data } = props ?? {};

    return adminSigninAuthAdminSigninPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminSigninAuthAdminSigninPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminSigninAuthAdminSigninPost>>
>;
export type AdminSigninAuthAdminSigninPostMutationBody = UserLogin;
export type AdminSigninAuthAdminSigninPostMutationError = HTTPValidationError;

/**
 * @summary Admin Signin
 */
export const useAdminSigninAuthAdminSigninPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof adminSigninAuthAdminSigninPost>>,
      TError,
      { data: UserLogin },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof adminSigninAuthAdminSigninPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationOptions =
    getAdminSigninAuthAdminSigninPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new client account
 * @summary Create Client
 */
export const createClientClientsPost = (
  userCreate: UserCreate,
  signal?: AbortSignal,
) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/clients/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userCreate,
    signal,
  });
};

export const getCreateClientClientsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClientClientsPost>>,
    TError,
    { data: UserCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClientClientsPost>>,
  TError,
  { data: UserCreate },
  TContext
> => {
  const mutationKey = ["createClientClientsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClientClientsPost>>,
    { data: UserCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createClientClientsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClientClientsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClientClientsPost>>
>;
export type CreateClientClientsPostMutationBody = UserCreate;
export type CreateClientClientsPostMutationError = HTTPValidationError;

/**
 * @summary Create Client
 */
export const useCreateClientClientsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createClientClientsPost>>,
      TError,
      { data: UserCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createClientClientsPost>>,
  TError,
  { data: UserCreate },
  TContext
> => {
  const mutationOptions = getCreateClientClientsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of clients
 * @summary Get Clients
 */
export const getClientsClientsGet = (
  params?: GetClientsClientsGetParams,
  signal?: AbortSignal,
) => {
  return api<PaginatedResponse>({
    url: `https://api.atuna.org/clients/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetClientsClientsGetQueryKey = (
  params?: GetClientsClientsGetParams,
) => {
  return [
    `https://api.atuna.org/clients/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetClientsClientsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getClientsClientsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetClientsClientsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientsClientsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClientsClientsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClientsClientsGet>>
  > = ({ signal }) => getClientsClientsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getClientsClientsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetClientsClientsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClientsClientsGet>>
>;
export type GetClientsClientsGetQueryError = HTTPValidationError;

export function useGetClientsClientsGet<
  TData = Awaited<ReturnType<typeof getClientsClientsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetClientsClientsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientsClientsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientsClientsGet>>,
          TError,
          Awaited<ReturnType<typeof getClientsClientsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetClientsClientsGet<
  TData = Awaited<ReturnType<typeof getClientsClientsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetClientsClientsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientsClientsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientsClientsGet>>,
          TError,
          Awaited<ReturnType<typeof getClientsClientsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetClientsClientsGet<
  TData = Awaited<ReturnType<typeof getClientsClientsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetClientsClientsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientsClientsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Clients
 */

export function useGetClientsClientsGet<
  TData = Awaited<ReturnType<typeof getClientsClientsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetClientsClientsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientsClientsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetClientsClientsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get client by ID
 * @summary Get Client
 */
export const getClientClientsClientIdGet = (
  clientId: string,
  signal?: AbortSignal,
) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/clients/${clientId}`,
    method: "GET",
    signal,
  });
};

export const getGetClientClientsClientIdGetQueryKey = (clientId?: string) => {
  return [`https://api.atuna.org/clients/${clientId}`] as const;
};

export const getGetClientClientsClientIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
  TError = HTTPValidationError,
>(
  clientId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetClientClientsClientIdGetQueryKey(clientId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getClientClientsClientIdGet>>
  > = ({ signal }) => getClientClientsClientIdGet(clientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!clientId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetClientClientsClientIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClientClientsClientIdGet>>
>;
export type GetClientClientsClientIdGetQueryError = HTTPValidationError;

export function useGetClientClientsClientIdGet<
  TData = Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
  TError = HTTPValidationError,
>(
  clientId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
          TError,
          Awaited<ReturnType<typeof getClientClientsClientIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetClientClientsClientIdGet<
  TData = Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
  TError = HTTPValidationError,
>(
  clientId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
          TError,
          Awaited<ReturnType<typeof getClientClientsClientIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetClientClientsClientIdGet<
  TData = Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
  TError = HTTPValidationError,
>(
  clientId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Client
 */

export function useGetClientClientsClientIdGet<
  TData = Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
  TError = HTTPValidationError,
>(
  clientId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getClientClientsClientIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetClientClientsClientIdGetQueryOptions(
    clientId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update client information
 * @summary Update Client
 */
export const updateClientClientsClientIdPut = (
  clientId: string,
  userUpdate: UserUpdate,
) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/clients/${clientId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userUpdate,
  });
};

export const getUpdateClientClientsClientIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClientClientsClientIdPut>>,
    TError,
    { clientId: string; data: UserUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClientClientsClientIdPut>>,
  TError,
  { clientId: string; data: UserUpdate },
  TContext
> => {
  const mutationKey = ["updateClientClientsClientIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClientClientsClientIdPut>>,
    { clientId: string; data: UserUpdate }
  > = (props) => {
    const { clientId, data } = props ?? {};

    return updateClientClientsClientIdPut(clientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClientClientsClientIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClientClientsClientIdPut>>
>;
export type UpdateClientClientsClientIdPutMutationBody = UserUpdate;
export type UpdateClientClientsClientIdPutMutationError = HTTPValidationError;

/**
 * @summary Update Client
 */
export const useUpdateClientClientsClientIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateClientClientsClientIdPut>>,
      TError,
      { clientId: string; data: UserUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateClientClientsClientIdPut>>,
  TError,
  { clientId: string; data: UserUpdate },
  TContext
> => {
  const mutationOptions =
    getUpdateClientClientsClientIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Archive client (soft delete)
 * @summary Archive Client
 */
export const archiveClientClientsClientIdDelete = (clientId: string) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/clients/${clientId}`,
    method: "DELETE",
  });
};

export const getArchiveClientClientsClientIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archiveClientClientsClientIdDelete>>,
    TError,
    { clientId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof archiveClientClientsClientIdDelete>>,
  TError,
  { clientId: string },
  TContext
> => {
  const mutationKey = ["archiveClientClientsClientIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof archiveClientClientsClientIdDelete>>,
    { clientId: string }
  > = (props) => {
    const { clientId } = props ?? {};

    return archiveClientClientsClientIdDelete(clientId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ArchiveClientClientsClientIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof archiveClientClientsClientIdDelete>>
>;

export type ArchiveClientClientsClientIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Archive Client
 */
export const useArchiveClientClientsClientIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archiveClientClientsClientIdDelete>>,
      TError,
      { clientId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof archiveClientClientsClientIdDelete>>,
  TError,
  { clientId: string },
  TContext
> => {
  const mutationOptions =
    getArchiveClientClientsClientIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new developer account
 * @summary Create Developer
 */
export const createDeveloperDevelopersPost = (
  bodyCreateDeveloperDevelopersPost: BodyCreateDeveloperDevelopersPost,
  signal?: AbortSignal,
) => {
  return api<DeveloperResponse>({
    url: `https://api.atuna.org/developers/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: bodyCreateDeveloperDevelopersPost,
    signal,
  });
};

export const getCreateDeveloperDevelopersPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDeveloperDevelopersPost>>,
    TError,
    { data: BodyCreateDeveloperDevelopersPost },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDeveloperDevelopersPost>>,
  TError,
  { data: BodyCreateDeveloperDevelopersPost },
  TContext
> => {
  const mutationKey = ["createDeveloperDevelopersPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDeveloperDevelopersPost>>,
    { data: BodyCreateDeveloperDevelopersPost }
  > = (props) => {
    const { data } = props ?? {};

    return createDeveloperDevelopersPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDeveloperDevelopersPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDeveloperDevelopersPost>>
>;
export type CreateDeveloperDevelopersPostMutationBody =
  BodyCreateDeveloperDevelopersPost;
export type CreateDeveloperDevelopersPostMutationError = HTTPValidationError;

/**
 * @summary Create Developer
 */
export const useCreateDeveloperDevelopersPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDeveloperDevelopersPost>>,
      TError,
      { data: BodyCreateDeveloperDevelopersPost },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDeveloperDevelopersPost>>,
  TError,
  { data: BodyCreateDeveloperDevelopersPost },
  TContext
> => {
  const mutationOptions =
    getCreateDeveloperDevelopersPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of developers
 * @summary Get Developers
 */
export const getDevelopersDevelopersGet = (
  params?: GetDevelopersDevelopersGetParams,
  signal?: AbortSignal,
) => {
  return api<PaginatedResponse>({
    url: `https://api.atuna.org/developers/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDevelopersDevelopersGetQueryKey = (
  params?: GetDevelopersDevelopersGetParams,
) => {
  return [
    `https://api.atuna.org/developers/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetDevelopersDevelopersGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDevelopersDevelopersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDevelopersDevelopersGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDevelopersDevelopersGet>>
  > = ({ signal }) => getDevelopersDevelopersGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDevelopersDevelopersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDevelopersDevelopersGet>>
>;
export type GetDevelopersDevelopersGetQueryError = HTTPValidationError;

export function useGetDevelopersDevelopersGet<
  TData = Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetDevelopersDevelopersGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
          TError,
          Awaited<ReturnType<typeof getDevelopersDevelopersGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDevelopersDevelopersGet<
  TData = Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDevelopersDevelopersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
          TError,
          Awaited<ReturnType<typeof getDevelopersDevelopersGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDevelopersDevelopersGet<
  TData = Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDevelopersDevelopersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Developers
 */

export function useGetDevelopersDevelopersGet<
  TData = Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDevelopersDevelopersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDevelopersDevelopersGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDevelopersDevelopersGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get developer by ID
 * @summary Get Developer
 */
export const getDeveloperDevelopersDeveloperIdGet = (
  developerId: string,
  signal?: AbortSignal,
) => {
  return api<DeveloperResponse>({
    url: `https://api.atuna.org/developers/${developerId}`,
    method: "GET",
    signal,
  });
};

export const getGetDeveloperDevelopersDeveloperIdGetQueryKey = (
  developerId?: string,
) => {
  return [`https://api.atuna.org/developers/${developerId}`] as const;
};

export const getGetDeveloperDevelopersDeveloperIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
  TError = HTTPValidationError,
>(
  developerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetDeveloperDevelopersDeveloperIdGetQueryKey(developerId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>
  > = ({ signal }) => getDeveloperDevelopersDeveloperIdGet(developerId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!developerId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDeveloperDevelopersDeveloperIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>
>;
export type GetDeveloperDevelopersDeveloperIdGetQueryError =
  HTTPValidationError;

export function useGetDeveloperDevelopersDeveloperIdGet<
  TData = Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
  TError = HTTPValidationError,
>(
  developerId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDeveloperDevelopersDeveloperIdGet<
  TData = Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
  TError = HTTPValidationError,
>(
  developerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDeveloperDevelopersDeveloperIdGet<
  TData = Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
  TError = HTTPValidationError,
>(
  developerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Developer
 */

export function useGetDeveloperDevelopersDeveloperIdGet<
  TData = Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
  TError = HTTPValidationError,
>(
  developerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeveloperDevelopersDeveloperIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDeveloperDevelopersDeveloperIdGetQueryOptions(
    developerId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update developer information
 * @summary Update Developer
 */
export const updateDeveloperDevelopersDeveloperIdPut = (
  developerId: string,
  developerCreate: DeveloperCreate,
) => {
  return api<DeveloperResponse>({
    url: `https://api.atuna.org/developers/${developerId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: developerCreate,
  });
};

export const getUpdateDeveloperDevelopersDeveloperIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeveloperDevelopersDeveloperIdPut>>,
    TError,
    { developerId: string; data: DeveloperCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeveloperDevelopersDeveloperIdPut>>,
  TError,
  { developerId: string; data: DeveloperCreate },
  TContext
> => {
  const mutationKey = ["updateDeveloperDevelopersDeveloperIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeveloperDevelopersDeveloperIdPut>>,
    { developerId: string; data: DeveloperCreate }
  > = (props) => {
    const { developerId, data } = props ?? {};

    return updateDeveloperDevelopersDeveloperIdPut(developerId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeveloperDevelopersDeveloperIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDeveloperDevelopersDeveloperIdPut>>
>;
export type UpdateDeveloperDevelopersDeveloperIdPutMutationBody =
  DeveloperCreate;
export type UpdateDeveloperDevelopersDeveloperIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Developer
 */
export const useUpdateDeveloperDevelopersDeveloperIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDeveloperDevelopersDeveloperIdPut>>,
      TError,
      { developerId: string; data: DeveloperCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateDeveloperDevelopersDeveloperIdPut>>,
  TError,
  { developerId: string; data: DeveloperCreate },
  TContext
> => {
  const mutationOptions =
    getUpdateDeveloperDevelopersDeveloperIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete developer
 * @summary Delete Developer
 */
export const deleteDeveloperDevelopersDeveloperIdDelete = (
  developerId: string,
) => {
  return api<DeveloperResponse>({
    url: `https://api.atuna.org/developers/${developerId}`,
    method: "DELETE",
  });
};

export const getDeleteDeveloperDevelopersDeveloperIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDeveloperDevelopersDeveloperIdDelete>>,
    TError,
    { developerId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteDeveloperDevelopersDeveloperIdDelete>>,
  TError,
  { developerId: string },
  TContext
> => {
  const mutationKey = ["deleteDeveloperDevelopersDeveloperIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDeveloperDevelopersDeveloperIdDelete>>,
    { developerId: string }
  > = (props) => {
    const { developerId } = props ?? {};

    return deleteDeveloperDevelopersDeveloperIdDelete(developerId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteDeveloperDevelopersDeveloperIdDeleteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteDeveloperDevelopersDeveloperIdDelete>>
  >;

export type DeleteDeveloperDevelopersDeveloperIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Developer
 */
export const useDeleteDeveloperDevelopersDeveloperIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteDeveloperDevelopersDeveloperIdDelete>>,
      TError,
      { developerId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteDeveloperDevelopersDeveloperIdDelete>>,
  TError,
  { developerId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteDeveloperDevelopersDeveloperIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new agent account
 * @summary Create Agent
 */
export const createAgentAgentsPost = (
  bodyCreateAgentAgentsPost: BodyCreateAgentAgentsPost,
  signal?: AbortSignal,
) => {
  return api<AgentResponse>({
    url: `https://api.atuna.org/agents/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: bodyCreateAgentAgentsPost,
    signal,
  });
};

export const getCreateAgentAgentsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAgentAgentsPost>>,
    TError,
    { data: BodyCreateAgentAgentsPost },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAgentAgentsPost>>,
  TError,
  { data: BodyCreateAgentAgentsPost },
  TContext
> => {
  const mutationKey = ["createAgentAgentsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAgentAgentsPost>>,
    { data: BodyCreateAgentAgentsPost }
  > = (props) => {
    const { data } = props ?? {};

    return createAgentAgentsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAgentAgentsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAgentAgentsPost>>
>;
export type CreateAgentAgentsPostMutationBody = BodyCreateAgentAgentsPost;
export type CreateAgentAgentsPostMutationError = HTTPValidationError;

/**
 * @summary Create Agent
 */
export const useCreateAgentAgentsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAgentAgentsPost>>,
      TError,
      { data: BodyCreateAgentAgentsPost },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createAgentAgentsPost>>,
  TError,
  { data: BodyCreateAgentAgentsPost },
  TContext
> => {
  const mutationOptions = getCreateAgentAgentsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of agents
 * @summary Get Agents
 */
export const getAgentsAgentsGet = (
  params?: GetAgentsAgentsGetParams,
  signal?: AbortSignal,
) => {
  return api<PaginatedResponse>({
    url: `https://api.atuna.org/agents/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetAgentsAgentsGetQueryKey = (
  params?: GetAgentsAgentsGetParams,
) => {
  return [
    `https://api.atuna.org/agents/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAgentsAgentsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAgentsAgentsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAgentsAgentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentsAgentsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAgentsAgentsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAgentsAgentsGet>>
  > = ({ signal }) => getAgentsAgentsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAgentsAgentsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAgentsAgentsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAgentsAgentsGet>>
>;
export type GetAgentsAgentsGetQueryError = HTTPValidationError;

export function useGetAgentsAgentsGet<
  TData = Awaited<ReturnType<typeof getAgentsAgentsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetAgentsAgentsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentsAgentsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentsAgentsGet>>,
          TError,
          Awaited<ReturnType<typeof getAgentsAgentsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAgentsAgentsGet<
  TData = Awaited<ReturnType<typeof getAgentsAgentsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAgentsAgentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentsAgentsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentsAgentsGet>>,
          TError,
          Awaited<ReturnType<typeof getAgentsAgentsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAgentsAgentsGet<
  TData = Awaited<ReturnType<typeof getAgentsAgentsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAgentsAgentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentsAgentsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Agents
 */

export function useGetAgentsAgentsGet<
  TData = Awaited<ReturnType<typeof getAgentsAgentsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAgentsAgentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentsAgentsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAgentsAgentsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get agent by ID
 * @summary Get Agent
 */
export const getAgentAgentsAgentIdGet = (
  agentId: string,
  signal?: AbortSignal,
) => {
  return api<AgentResponse>({
    url: `https://api.atuna.org/agents/${agentId}`,
    method: "GET",
    signal,
  });
};

export const getGetAgentAgentsAgentIdGetQueryKey = (agentId?: string) => {
  return [`https://api.atuna.org/agents/${agentId}`] as const;
};

export const getGetAgentAgentsAgentIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
  TError = HTTPValidationError,
>(
  agentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAgentAgentsAgentIdGetQueryKey(agentId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>
  > = ({ signal }) => getAgentAgentsAgentIdGet(agentId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!agentId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAgentAgentsAgentIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>
>;
export type GetAgentAgentsAgentIdGetQueryError = HTTPValidationError;

export function useGetAgentAgentsAgentIdGet<
  TData = Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
  TError = HTTPValidationError,
>(
  agentId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAgentAgentsAgentIdGet<
  TData = Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
  TError = HTTPValidationError,
>(
  agentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAgentAgentsAgentIdGet<
  TData = Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
  TError = HTTPValidationError,
>(
  agentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Agent
 */

export function useGetAgentAgentsAgentIdGet<
  TData = Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
  TError = HTTPValidationError,
>(
  agentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAgentAgentsAgentIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAgentAgentsAgentIdGetQueryOptions(
    agentId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update agent information
 * @summary Update Agent
 */
export const updateAgentAgentsAgentIdPut = (
  agentId: string,
  agentCreate: AgentCreate,
) => {
  return api<AgentResponse>({
    url: `https://api.atuna.org/agents/${agentId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: agentCreate,
  });
};

export const getUpdateAgentAgentsAgentIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAgentAgentsAgentIdPut>>,
    TError,
    { agentId: string; data: AgentCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAgentAgentsAgentIdPut>>,
  TError,
  { agentId: string; data: AgentCreate },
  TContext
> => {
  const mutationKey = ["updateAgentAgentsAgentIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAgentAgentsAgentIdPut>>,
    { agentId: string; data: AgentCreate }
  > = (props) => {
    const { agentId, data } = props ?? {};

    return updateAgentAgentsAgentIdPut(agentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAgentAgentsAgentIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAgentAgentsAgentIdPut>>
>;
export type UpdateAgentAgentsAgentIdPutMutationBody = AgentCreate;
export type UpdateAgentAgentsAgentIdPutMutationError = HTTPValidationError;

/**
 * @summary Update Agent
 */
export const useUpdateAgentAgentsAgentIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAgentAgentsAgentIdPut>>,
      TError,
      { agentId: string; data: AgentCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateAgentAgentsAgentIdPut>>,
  TError,
  { agentId: string; data: AgentCreate },
  TContext
> => {
  const mutationOptions =
    getUpdateAgentAgentsAgentIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete agent
 * @summary Delete Agent
 */
export const deleteAgentAgentsAgentIdDelete = (agentId: string) => {
  return api<AgentResponse>({
    url: `https://api.atuna.org/agents/${agentId}`,
    method: "DELETE",
  });
};

export const getDeleteAgentAgentsAgentIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAgentAgentsAgentIdDelete>>,
    TError,
    { agentId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAgentAgentsAgentIdDelete>>,
  TError,
  { agentId: string },
  TContext
> => {
  const mutationKey = ["deleteAgentAgentsAgentIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAgentAgentsAgentIdDelete>>,
    { agentId: string }
  > = (props) => {
    const { agentId } = props ?? {};

    return deleteAgentAgentsAgentIdDelete(agentId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAgentAgentsAgentIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAgentAgentsAgentIdDelete>>
>;

export type DeleteAgentAgentsAgentIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Agent
 */
export const useDeleteAgentAgentsAgentIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAgentAgentsAgentIdDelete>>,
      TError,
      { agentId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAgentAgentsAgentIdDelete>>,
  TError,
  { agentId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteAgentAgentsAgentIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new broker account
 * @summary Create Broker
 */
export const createBrokerBrokersPost = (
  bodyCreateBrokerBrokersPost: BodyCreateBrokerBrokersPost,
  signal?: AbortSignal,
) => {
  return api<BrokerResponse>({
    url: `https://api.atuna.org/brokers/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: bodyCreateBrokerBrokersPost,
    signal,
  });
};

export const getCreateBrokerBrokersPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createBrokerBrokersPost>>,
    TError,
    { data: BodyCreateBrokerBrokersPost },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createBrokerBrokersPost>>,
  TError,
  { data: BodyCreateBrokerBrokersPost },
  TContext
> => {
  const mutationKey = ["createBrokerBrokersPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createBrokerBrokersPost>>,
    { data: BodyCreateBrokerBrokersPost }
  > = (props) => {
    const { data } = props ?? {};

    return createBrokerBrokersPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateBrokerBrokersPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createBrokerBrokersPost>>
>;
export type CreateBrokerBrokersPostMutationBody = BodyCreateBrokerBrokersPost;
export type CreateBrokerBrokersPostMutationError = HTTPValidationError;

/**
 * @summary Create Broker
 */
export const useCreateBrokerBrokersPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createBrokerBrokersPost>>,
      TError,
      { data: BodyCreateBrokerBrokersPost },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createBrokerBrokersPost>>,
  TError,
  { data: BodyCreateBrokerBrokersPost },
  TContext
> => {
  const mutationOptions = getCreateBrokerBrokersPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of brokers
 * @summary Get Brokers
 */
export const getBrokersBrokersGet = (
  params?: GetBrokersBrokersGetParams,
  signal?: AbortSignal,
) => {
  return api<PaginatedResponse>({
    url: `https://api.atuna.org/brokers/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetBrokersBrokersGetQueryKey = (
  params?: GetBrokersBrokersGetParams,
) => {
  return [
    `https://api.atuna.org/brokers/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetBrokersBrokersGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBrokersBrokersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBrokersBrokersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokersBrokersGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBrokersBrokersGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBrokersBrokersGet>>
  > = ({ signal }) => getBrokersBrokersGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getBrokersBrokersGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBrokersBrokersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBrokersBrokersGet>>
>;
export type GetBrokersBrokersGetQueryError = HTTPValidationError;

export function useGetBrokersBrokersGet<
  TData = Awaited<ReturnType<typeof getBrokersBrokersGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetBrokersBrokersGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokersBrokersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrokersBrokersGet>>,
          TError,
          Awaited<ReturnType<typeof getBrokersBrokersGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBrokersBrokersGet<
  TData = Awaited<ReturnType<typeof getBrokersBrokersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBrokersBrokersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokersBrokersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrokersBrokersGet>>,
          TError,
          Awaited<ReturnType<typeof getBrokersBrokersGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBrokersBrokersGet<
  TData = Awaited<ReturnType<typeof getBrokersBrokersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBrokersBrokersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokersBrokersGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Brokers
 */

export function useGetBrokersBrokersGet<
  TData = Awaited<ReturnType<typeof getBrokersBrokersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBrokersBrokersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokersBrokersGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetBrokersBrokersGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get broker by ID
 * @summary Get Broker
 */
export const getBrokerBrokersBrokerIdGet = (
  brokerId: string,
  signal?: AbortSignal,
) => {
  return api<BrokerResponse>({
    url: `https://api.atuna.org/brokers/${brokerId}`,
    method: "GET",
    signal,
  });
};

export const getGetBrokerBrokersBrokerIdGetQueryKey = (brokerId?: string) => {
  return [`https://api.atuna.org/brokers/${brokerId}`] as const;
};

export const getGetBrokerBrokersBrokerIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
  TError = HTTPValidationError,
>(
  brokerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBrokerBrokersBrokerIdGetQueryKey(brokerId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>
  > = ({ signal }) => getBrokerBrokersBrokerIdGet(brokerId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!brokerId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBrokerBrokersBrokerIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>
>;
export type GetBrokerBrokersBrokerIdGetQueryError = HTTPValidationError;

export function useGetBrokerBrokersBrokerIdGet<
  TData = Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
  TError = HTTPValidationError,
>(
  brokerId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBrokerBrokersBrokerIdGet<
  TData = Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
  TError = HTTPValidationError,
>(
  brokerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBrokerBrokersBrokerIdGet<
  TData = Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
  TError = HTTPValidationError,
>(
  brokerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Broker
 */

export function useGetBrokerBrokersBrokerIdGet<
  TData = Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
  TError = HTTPValidationError,
>(
  brokerId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBrokerBrokersBrokerIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetBrokerBrokersBrokerIdGetQueryOptions(
    brokerId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update broker information
 * @summary Update Broker
 */
export const updateBrokerBrokersBrokerIdPut = (
  brokerId: string,
  brokerCreate: BrokerCreate,
) => {
  return api<BrokerResponse>({
    url: `https://api.atuna.org/brokers/${brokerId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: brokerCreate,
  });
};

export const getUpdateBrokerBrokersBrokerIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBrokerBrokersBrokerIdPut>>,
    TError,
    { brokerId: string; data: BrokerCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBrokerBrokersBrokerIdPut>>,
  TError,
  { brokerId: string; data: BrokerCreate },
  TContext
> => {
  const mutationKey = ["updateBrokerBrokersBrokerIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBrokerBrokersBrokerIdPut>>,
    { brokerId: string; data: BrokerCreate }
  > = (props) => {
    const { brokerId, data } = props ?? {};

    return updateBrokerBrokersBrokerIdPut(brokerId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateBrokerBrokersBrokerIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateBrokerBrokersBrokerIdPut>>
>;
export type UpdateBrokerBrokersBrokerIdPutMutationBody = BrokerCreate;
export type UpdateBrokerBrokersBrokerIdPutMutationError = HTTPValidationError;

/**
 * @summary Update Broker
 */
export const useUpdateBrokerBrokersBrokerIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBrokerBrokersBrokerIdPut>>,
      TError,
      { brokerId: string; data: BrokerCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateBrokerBrokersBrokerIdPut>>,
  TError,
  { brokerId: string; data: BrokerCreate },
  TContext
> => {
  const mutationOptions =
    getUpdateBrokerBrokersBrokerIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete broker
 * @summary Delete Broker
 */
export const deleteBrokerBrokersBrokerIdDelete = (brokerId: string) => {
  return api<BrokerResponse>({
    url: `https://api.atuna.org/brokers/${brokerId}`,
    method: "DELETE",
  });
};

export const getDeleteBrokerBrokersBrokerIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteBrokerBrokersBrokerIdDelete>>,
    TError,
    { brokerId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteBrokerBrokersBrokerIdDelete>>,
  TError,
  { brokerId: string },
  TContext
> => {
  const mutationKey = ["deleteBrokerBrokersBrokerIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteBrokerBrokersBrokerIdDelete>>,
    { brokerId: string }
  > = (props) => {
    const { brokerId } = props ?? {};

    return deleteBrokerBrokersBrokerIdDelete(brokerId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteBrokerBrokersBrokerIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteBrokerBrokersBrokerIdDelete>>
>;

export type DeleteBrokerBrokersBrokerIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Broker
 */
export const useDeleteBrokerBrokersBrokerIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteBrokerBrokersBrokerIdDelete>>,
      TError,
      { brokerId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteBrokerBrokersBrokerIdDelete>>,
  TError,
  { brokerId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteBrokerBrokersBrokerIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new admin account
 * @summary Create Admin
 */
export const createAdminAdminsPost = (
  userCreate: UserCreate,
  signal?: AbortSignal,
) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/admins/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userCreate,
    signal,
  });
};

export const getCreateAdminAdminsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdminAdminsPost>>,
    TError,
    { data: UserCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAdminAdminsPost>>,
  TError,
  { data: UserCreate },
  TContext
> => {
  const mutationKey = ["createAdminAdminsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAdminAdminsPost>>,
    { data: UserCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createAdminAdminsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAdminAdminsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAdminAdminsPost>>
>;
export type CreateAdminAdminsPostMutationBody = UserCreate;
export type CreateAdminAdminsPostMutationError = HTTPValidationError;

/**
 * @summary Create Admin
 */
export const useCreateAdminAdminsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAdminAdminsPost>>,
      TError,
      { data: UserCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createAdminAdminsPost>>,
  TError,
  { data: UserCreate },
  TContext
> => {
  const mutationOptions = getCreateAdminAdminsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of admins
 * @summary Get Admins
 */
export const getAdminsAdminsGet = (
  params?: GetAdminsAdminsGetParams,
  signal?: AbortSignal,
) => {
  return api<PaginatedResponse>({
    url: `https://api.atuna.org/admins/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetAdminsAdminsGetQueryKey = (
  params?: GetAdminsAdminsGetParams,
) => {
  return [
    `https://api.atuna.org/admins/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAdminsAdminsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdminsAdminsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAdminsAdminsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminsAdminsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAdminsAdminsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAdminsAdminsGet>>
  > = ({ signal }) => getAdminsAdminsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAdminsAdminsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAdminsAdminsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAdminsAdminsGet>>
>;
export type GetAdminsAdminsGetQueryError = HTTPValidationError;

export function useGetAdminsAdminsGet<
  TData = Awaited<ReturnType<typeof getAdminsAdminsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetAdminsAdminsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminsAdminsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminsAdminsGet>>,
          TError,
          Awaited<ReturnType<typeof getAdminsAdminsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAdminsAdminsGet<
  TData = Awaited<ReturnType<typeof getAdminsAdminsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAdminsAdminsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminsAdminsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminsAdminsGet>>,
          TError,
          Awaited<ReturnType<typeof getAdminsAdminsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAdminsAdminsGet<
  TData = Awaited<ReturnType<typeof getAdminsAdminsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAdminsAdminsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminsAdminsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Admins
 */

export function useGetAdminsAdminsGet<
  TData = Awaited<ReturnType<typeof getAdminsAdminsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAdminsAdminsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminsAdminsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAdminsAdminsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get admin by ID
 * @summary Get Admin
 */
export const getAdminAdminsAdminIdGet = (
  adminId: string,
  signal?: AbortSignal,
) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/admins/${adminId}`,
    method: "GET",
    signal,
  });
};

export const getGetAdminAdminsAdminIdGetQueryKey = (adminId?: string) => {
  return [`https://api.atuna.org/admins/${adminId}`] as const;
};

export const getGetAdminAdminsAdminIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
  TError = HTTPValidationError,
>(
  adminId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAdminAdminsAdminIdGetQueryKey(adminId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>
  > = ({ signal }) => getAdminAdminsAdminIdGet(adminId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!adminId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAdminAdminsAdminIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>
>;
export type GetAdminAdminsAdminIdGetQueryError = HTTPValidationError;

export function useGetAdminAdminsAdminIdGet<
  TData = Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
  TError = HTTPValidationError,
>(
  adminId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAdminAdminsAdminIdGet<
  TData = Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
  TError = HTTPValidationError,
>(
  adminId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAdminAdminsAdminIdGet<
  TData = Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
  TError = HTTPValidationError,
>(
  adminId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Admin
 */

export function useGetAdminAdminsAdminIdGet<
  TData = Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
  TError = HTTPValidationError,
>(
  adminId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAdminAdminsAdminIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAdminAdminsAdminIdGetQueryOptions(
    adminId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update admin information
 * @summary Update Admin
 */
export const updateAdminAdminsAdminIdPut = (
  adminId: string,
  userUpdate: UserUpdate,
) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/admins/${adminId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userUpdate,
  });
};

export const getUpdateAdminAdminsAdminIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAdminAdminsAdminIdPut>>,
    TError,
    { adminId: string; data: UserUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAdminAdminsAdminIdPut>>,
  TError,
  { adminId: string; data: UserUpdate },
  TContext
> => {
  const mutationKey = ["updateAdminAdminsAdminIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAdminAdminsAdminIdPut>>,
    { adminId: string; data: UserUpdate }
  > = (props) => {
    const { adminId, data } = props ?? {};

    return updateAdminAdminsAdminIdPut(adminId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAdminAdminsAdminIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAdminAdminsAdminIdPut>>
>;
export type UpdateAdminAdminsAdminIdPutMutationBody = UserUpdate;
export type UpdateAdminAdminsAdminIdPutMutationError = HTTPValidationError;

/**
 * @summary Update Admin
 */
export const useUpdateAdminAdminsAdminIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAdminAdminsAdminIdPut>>,
      TError,
      { adminId: string; data: UserUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateAdminAdminsAdminIdPut>>,
  TError,
  { adminId: string; data: UserUpdate },
  TContext
> => {
  const mutationOptions =
    getUpdateAdminAdminsAdminIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Archive admin (soft delete)
 * @summary Archive Admin
 */
export const archiveAdminAdminsAdminIdDelete = (adminId: string) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/admins/${adminId}`,
    method: "DELETE",
  });
};

export const getArchiveAdminAdminsAdminIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archiveAdminAdminsAdminIdDelete>>,
    TError,
    { adminId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof archiveAdminAdminsAdminIdDelete>>,
  TError,
  { adminId: string },
  TContext
> => {
  const mutationKey = ["archiveAdminAdminsAdminIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof archiveAdminAdminsAdminIdDelete>>,
    { adminId: string }
  > = (props) => {
    const { adminId } = props ?? {};

    return archiveAdminAdminsAdminIdDelete(adminId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ArchiveAdminAdminsAdminIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof archiveAdminAdminsAdminIdDelete>>
>;

export type ArchiveAdminAdminsAdminIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Archive Admin
 */
export const useArchiveAdminAdminsAdminIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archiveAdminAdminsAdminIdDelete>>,
      TError,
      { adminId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof archiveAdminAdminsAdminIdDelete>>,
  TError,
  { adminId: string },
  TContext
> => {
  const mutationOptions =
    getArchiveAdminAdminsAdminIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Add property to bookmarks
 * @summary Add Bookmark
 */
export const addBookmarkBookmarksPost = (
  bookmarkCreate: BookmarkCreate,
  signal?: AbortSignal,
) => {
  return api<BookmarkResponse>({
    url: `https://api.atuna.org/bookmarks/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: bookmarkCreate,
    signal,
  });
};

export const getAddBookmarkBookmarksPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addBookmarkBookmarksPost>>,
    TError,
    { data: BookmarkCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addBookmarkBookmarksPost>>,
  TError,
  { data: BookmarkCreate },
  TContext
> => {
  const mutationKey = ["addBookmarkBookmarksPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addBookmarkBookmarksPost>>,
    { data: BookmarkCreate }
  > = (props) => {
    const { data } = props ?? {};

    return addBookmarkBookmarksPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddBookmarkBookmarksPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addBookmarkBookmarksPost>>
>;
export type AddBookmarkBookmarksPostMutationBody = BookmarkCreate;
export type AddBookmarkBookmarksPostMutationError = HTTPValidationError;

/**
 * @summary Add Bookmark
 */
export const useAddBookmarkBookmarksPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addBookmarkBookmarksPost>>,
      TError,
      { data: BookmarkCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addBookmarkBookmarksPost>>,
  TError,
  { data: BookmarkCreate },
  TContext
> => {
  const mutationOptions = getAddBookmarkBookmarksPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of user's bookmarks
 * @summary Get Bookmarks
 */
export const getBookmarksBookmarksGet = (
  params?: GetBookmarksBookmarksGetParams,
  signal?: AbortSignal,
) => {
  return api<PaginatedResponse>({
    url: `https://api.atuna.org/bookmarks/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetBookmarksBookmarksGetQueryKey = (
  params?: GetBookmarksBookmarksGetParams,
) => {
  return [
    `https://api.atuna.org/bookmarks/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetBookmarksBookmarksGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBookmarksBookmarksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBookmarksBookmarksGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookmarksBookmarksGet>>
  > = ({ signal }) => getBookmarksBookmarksGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookmarksBookmarksGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookmarksBookmarksGet>>
>;
export type GetBookmarksBookmarksGetQueryError = HTTPValidationError;

export function useGetBookmarksBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetBookmarksBookmarksGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
          TError,
          Awaited<ReturnType<typeof getBookmarksBookmarksGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBookmarksBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBookmarksBookmarksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
          TError,
          Awaited<ReturnType<typeof getBookmarksBookmarksGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBookmarksBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBookmarksBookmarksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Bookmarks
 */

export function useGetBookmarksBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBookmarksBookmarksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksBookmarksGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetBookmarksBookmarksGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get bookmark by ID
 * @summary Get Bookmark
 */
export const getBookmarkBookmarksBookmarkIdGet = (
  bookmarkId: string,
  signal?: AbortSignal,
) => {
  return api<BookmarkResponse>({
    url: `https://api.atuna.org/bookmarks/${bookmarkId}`,
    method: "GET",
    signal,
  });
};

export const getGetBookmarkBookmarksBookmarkIdGetQueryKey = (
  bookmarkId?: string,
) => {
  return [`https://api.atuna.org/bookmarks/${bookmarkId}`] as const;
};

export const getGetBookmarkBookmarksBookmarkIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
  TError = HTTPValidationError,
>(
  bookmarkId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBookmarkBookmarksBookmarkIdGetQueryKey(bookmarkId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>
  > = ({ signal }) => getBookmarkBookmarksBookmarkIdGet(bookmarkId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!bookmarkId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookmarkBookmarksBookmarkIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>
>;
export type GetBookmarkBookmarksBookmarkIdGetQueryError = HTTPValidationError;

export function useGetBookmarkBookmarksBookmarkIdGet<
  TData = Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
  TError = HTTPValidationError,
>(
  bookmarkId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBookmarkBookmarksBookmarkIdGet<
  TData = Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
  TError = HTTPValidationError,
>(
  bookmarkId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBookmarkBookmarksBookmarkIdGet<
  TData = Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
  TError = HTTPValidationError,
>(
  bookmarkId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Bookmark
 */

export function useGetBookmarkBookmarksBookmarkIdGet<
  TData = Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
  TError = HTTPValidationError,
>(
  bookmarkId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarkBookmarksBookmarkIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetBookmarkBookmarksBookmarkIdGetQueryOptions(
    bookmarkId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Remove bookmark
 * @summary Remove Bookmark
 */
export const removeBookmarkBookmarksBookmarkIdDelete = (bookmarkId: string) => {
  return api<unknown>({
    url: `https://api.atuna.org/bookmarks/${bookmarkId}`,
    method: "DELETE",
  });
};

export const getRemoveBookmarkBookmarksBookmarkIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeBookmarkBookmarksBookmarkIdDelete>>,
    TError,
    { bookmarkId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeBookmarkBookmarksBookmarkIdDelete>>,
  TError,
  { bookmarkId: string },
  TContext
> => {
  const mutationKey = ["removeBookmarkBookmarksBookmarkIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeBookmarkBookmarksBookmarkIdDelete>>,
    { bookmarkId: string }
  > = (props) => {
    const { bookmarkId } = props ?? {};

    return removeBookmarkBookmarksBookmarkIdDelete(bookmarkId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveBookmarkBookmarksBookmarkIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeBookmarkBookmarksBookmarkIdDelete>>
>;

export type RemoveBookmarkBookmarksBookmarkIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Remove Bookmark
 */
export const useRemoveBookmarkBookmarksBookmarkIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeBookmarkBookmarksBookmarkIdDelete>>,
      TError,
      { bookmarkId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeBookmarkBookmarksBookmarkIdDelete>>,
  TError,
  { bookmarkId: string },
  TContext
> => {
  const mutationOptions =
    getRemoveBookmarkBookmarksBookmarkIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of user's notifications
 * @summary Get Notifications
 */
export const getNotificationsNotificationsGet = (
  params?: GetNotificationsNotificationsGetParams,
  signal?: AbortSignal,
) => {
  return api<PaginatedResponse>({
    url: `https://api.atuna.org/notifications/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetNotificationsNotificationsGetQueryKey = (
  params?: GetNotificationsNotificationsGetParams,
) => {
  return [
    `https://api.atuna.org/notifications/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetNotificationsNotificationsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetNotificationsNotificationsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetNotificationsNotificationsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNotificationsNotificationsGet>>
  > = ({ signal }) => getNotificationsNotificationsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsNotificationsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationsNotificationsGet>>
>;
export type GetNotificationsNotificationsGetQueryError = HTTPValidationError;

export function useGetNotificationsNotificationsGet<
  TData = Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetNotificationsNotificationsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
          TError,
          Awaited<ReturnType<typeof getNotificationsNotificationsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNotificationsNotificationsGet<
  TData = Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetNotificationsNotificationsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
          TError,
          Awaited<ReturnType<typeof getNotificationsNotificationsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNotificationsNotificationsGet<
  TData = Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetNotificationsNotificationsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Notifications
 */

export function useGetNotificationsNotificationsGet<
  TData = Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetNotificationsNotificationsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsNotificationsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNotificationsNotificationsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Mark all notifications as read
 * @summary Mark All Notifications As Read
 */
export const markAllNotificationsAsReadNotificationsPut = () => {
  return api<MarkAllNotificationsAsReadNotificationsPut200>({
    url: `https://api.atuna.org/notifications/`,
    method: "PUT",
  });
};

export const getMarkAllNotificationsAsReadNotificationsPutMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markAllNotificationsAsReadNotificationsPut>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof markAllNotificationsAsReadNotificationsPut>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["markAllNotificationsAsReadNotificationsPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markAllNotificationsAsReadNotificationsPut>>,
    void
  > = () => {
    return markAllNotificationsAsReadNotificationsPut();
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkAllNotificationsAsReadNotificationsPutMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof markAllNotificationsAsReadNotificationsPut>>
  >;

export type MarkAllNotificationsAsReadNotificationsPutMutationError = unknown;

/**
 * @summary Mark All Notifications As Read
 */
export const useMarkAllNotificationsAsReadNotificationsPut = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markAllNotificationsAsReadNotificationsPut>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof markAllNotificationsAsReadNotificationsPut>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getMarkAllNotificationsAsReadNotificationsPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a notification for a user (admin/developer/broker only)
 * @summary Create Notification
 */
export const createNotificationNotificationsPost = (
  notificationCreate: NotificationCreate,
  params: CreateNotificationNotificationsPostParams,
  signal?: AbortSignal,
) => {
  return api<NotificationResponse>({
    url: `https://api.atuna.org/notifications/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: notificationCreate,
    params,
    signal,
  });
};

export const getCreateNotificationNotificationsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNotificationNotificationsPost>>,
    TError,
    {
      data: NotificationCreate;
      params: CreateNotificationNotificationsPostParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNotificationNotificationsPost>>,
  TError,
  {
    data: NotificationCreate;
    params: CreateNotificationNotificationsPostParams;
  },
  TContext
> => {
  const mutationKey = ["createNotificationNotificationsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNotificationNotificationsPost>>,
    {
      data: NotificationCreate;
      params: CreateNotificationNotificationsPostParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return createNotificationNotificationsPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNotificationNotificationsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNotificationNotificationsPost>>
>;
export type CreateNotificationNotificationsPostMutationBody =
  NotificationCreate;
export type CreateNotificationNotificationsPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Notification
 */
export const useCreateNotificationNotificationsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createNotificationNotificationsPost>>,
      TError,
      {
        data: NotificationCreate;
        params: CreateNotificationNotificationsPostParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createNotificationNotificationsPost>>,
  TError,
  {
    data: NotificationCreate;
    params: CreateNotificationNotificationsPostParams;
  },
  TContext
> => {
  const mutationOptions =
    getCreateNotificationNotificationsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete notification
 * @summary Delete Notification
 */
export const deleteNotificationNotificationsNotificationIdDelete = (
  notificationId: string,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/notifications/${notificationId}`,
    method: "DELETE",
  });
};

export const getDeleteNotificationNotificationsNotificationIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteNotificationNotificationsNotificationIdDelete>
      >,
      TError,
      { notificationId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteNotificationNotificationsNotificationIdDelete>
    >,
    TError,
    { notificationId: string },
    TContext
  > => {
    const mutationKey = ["deleteNotificationNotificationsNotificationIdDelete"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteNotificationNotificationsNotificationIdDelete>
      >,
      { notificationId: string }
    > = (props) => {
      const { notificationId } = props ?? {};

      return deleteNotificationNotificationsNotificationIdDelete(
        notificationId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteNotificationNotificationsNotificationIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof deleteNotificationNotificationsNotificationIdDelete>
    >
  >;

export type DeleteNotificationNotificationsNotificationIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Notification
 */
export const useDeleteNotificationNotificationsNotificationIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteNotificationNotificationsNotificationIdDelete>
      >,
      TError,
      { notificationId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof deleteNotificationNotificationsNotificationIdDelete>
  >,
  TError,
  { notificationId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteNotificationNotificationsNotificationIdDeleteMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get teams (broker sees their teams, admin sees all)
 * @summary Get Teams
 */
export const getTeamsTeamsGet = (signal?: AbortSignal) => {
  return api<GetTeamsTeamsGet200Item[]>({
    url: `https://api.atuna.org/teams/`,
    method: "GET",
    signal,
  });
};

export const getGetTeamsTeamsGetQueryKey = () => {
  return [`https://api.atuna.org/teams/`] as const;
};

export const getGetTeamsTeamsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamsTeamsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getTeamsTeamsGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTeamsTeamsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamsTeamsGet>>
  > = ({ signal }) => getTeamsTeamsGet(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamsTeamsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamsTeamsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamsTeamsGet>>
>;
export type GetTeamsTeamsGetQueryError = unknown;

export function useGetTeamsTeamsGet<
  TData = Awaited<ReturnType<typeof getTeamsTeamsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsTeamsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamsTeamsGet>>,
          TError,
          Awaited<ReturnType<typeof getTeamsTeamsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamsTeamsGet<
  TData = Awaited<ReturnType<typeof getTeamsTeamsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsTeamsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamsTeamsGet>>,
          TError,
          Awaited<ReturnType<typeof getTeamsTeamsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamsTeamsGet<
  TData = Awaited<ReturnType<typeof getTeamsTeamsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsTeamsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Teams
 */

export function useGetTeamsTeamsGet<
  TData = Awaited<ReturnType<typeof getTeamsTeamsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsTeamsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamsTeamsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new team (brokers only)
 * @summary Create Team
 */
export const createTeamTeamsPost = (
  teamCreate: TeamCreate,
  signal?: AbortSignal,
) => {
  return api<CreateTeamTeamsPost200>({
    url: `https://api.atuna.org/teams/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: teamCreate,
    signal,
  });
};

export const getCreateTeamTeamsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTeamTeamsPost>>,
    TError,
    { data: TeamCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTeamTeamsPost>>,
  TError,
  { data: TeamCreate },
  TContext
> => {
  const mutationKey = ["createTeamTeamsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTeamTeamsPost>>,
    { data: TeamCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createTeamTeamsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTeamTeamsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTeamTeamsPost>>
>;
export type CreateTeamTeamsPostMutationBody = TeamCreate;
export type CreateTeamTeamsPostMutationError = HTTPValidationError;

/**
 * @summary Create Team
 */
export const useCreateTeamTeamsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTeamTeamsPost>>,
      TError,
      { data: TeamCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTeamTeamsPost>>,
  TError,
  { data: TeamCreate },
  TContext
> => {
  const mutationOptions = getCreateTeamTeamsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get detailed team information
 * @summary Get Team Details
 */
export const getTeamDetailsTeamsTeamIdGet = (
  teamId: string,
  signal?: AbortSignal,
) => {
  return api<GetTeamDetailsTeamsTeamIdGet200>({
    url: `https://api.atuna.org/teams/${teamId}`,
    method: "GET",
    signal,
  });
};

export const getGetTeamDetailsTeamsTeamIdGetQueryKey = (teamId?: string) => {
  return [`https://api.atuna.org/teams/${teamId}`] as const;
};

export const getGetTeamDetailsTeamsTeamIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamDetailsTeamsTeamIdGetQueryKey(teamId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>
  > = ({ signal }) => getTeamDetailsTeamsTeamIdGet(teamId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamDetailsTeamsTeamIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>
>;
export type GetTeamDetailsTeamsTeamIdGetQueryError = HTTPValidationError;

export function useGetTeamDetailsTeamsTeamIdGet<
  TData = Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamDetailsTeamsTeamIdGet<
  TData = Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamDetailsTeamsTeamIdGet<
  TData = Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Team Details
 */

export function useGetTeamDetailsTeamsTeamIdGet<
  TData = Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamDetailsTeamsTeamIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamDetailsTeamsTeamIdGetQueryOptions(
    teamId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Edit team info
 * @summary Update Team
 */
export const updateTeamTeamsTeamIdPut = (
  teamId: string,
  teamUpdate: TeamUpdate,
) => {
  return api<TeamResponse>({
    url: `https://api.atuna.org/teams/${teamId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: teamUpdate,
  });
};

export const getUpdateTeamTeamsTeamIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamTeamsTeamIdPut>>,
    TError,
    { teamId: string; data: TeamUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamTeamsTeamIdPut>>,
  TError,
  { teamId: string; data: TeamUpdate },
  TContext
> => {
  const mutationKey = ["updateTeamTeamsTeamIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamTeamsTeamIdPut>>,
    { teamId: string; data: TeamUpdate }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return updateTeamTeamsTeamIdPut(teamId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamTeamsTeamIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamTeamsTeamIdPut>>
>;
export type UpdateTeamTeamsTeamIdPutMutationBody = TeamUpdate;
export type UpdateTeamTeamsTeamIdPutMutationError = HTTPValidationError;

/**
 * @summary Update Team
 */
export const useUpdateTeamTeamsTeamIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamTeamsTeamIdPut>>,
      TError,
      { teamId: string; data: TeamUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamTeamsTeamIdPut>>,
  TError,
  { teamId: string; data: TeamUpdate },
  TContext
> => {
  const mutationOptions = getUpdateTeamTeamsTeamIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Archive team (soft delete)
 * @summary Archive Team
 */
export const archiveTeamTeamsTeamIdDelete = (teamId: string) => {
  return api<unknown>({
    url: `https://api.atuna.org/teams/${teamId}`,
    method: "DELETE",
  });
};

export const getArchiveTeamTeamsTeamIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archiveTeamTeamsTeamIdDelete>>,
    TError,
    { teamId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof archiveTeamTeamsTeamIdDelete>>,
  TError,
  { teamId: string },
  TContext
> => {
  const mutationKey = ["archiveTeamTeamsTeamIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof archiveTeamTeamsTeamIdDelete>>,
    { teamId: string }
  > = (props) => {
    const { teamId } = props ?? {};

    return archiveTeamTeamsTeamIdDelete(teamId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ArchiveTeamTeamsTeamIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof archiveTeamTeamsTeamIdDelete>>
>;

export type ArchiveTeamTeamsTeamIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Archive Team
 */
export const useArchiveTeamTeamsTeamIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archiveTeamTeamsTeamIdDelete>>,
      TError,
      { teamId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof archiveTeamTeamsTeamIdDelete>>,
  TError,
  { teamId: string },
  TContext
> => {
  const mutationOptions =
    getArchiveTeamTeamsTeamIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Add member to team
 * @summary Add Team Member
 */
export const addTeamMemberTeamsTeamIdMembersPost = (
  teamId: string,
  teamMemberCreate: TeamMemberCreate,
  signal?: AbortSignal,
) => {
  return api<TeamMemberResponse>({
    url: `https://api.atuna.org/teams/${teamId}/members`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: teamMemberCreate,
    signal,
  });
};

export const getAddTeamMemberTeamsTeamIdMembersPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addTeamMemberTeamsTeamIdMembersPost>>,
    TError,
    { teamId: string; data: TeamMemberCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addTeamMemberTeamsTeamIdMembersPost>>,
  TError,
  { teamId: string; data: TeamMemberCreate },
  TContext
> => {
  const mutationKey = ["addTeamMemberTeamsTeamIdMembersPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addTeamMemberTeamsTeamIdMembersPost>>,
    { teamId: string; data: TeamMemberCreate }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return addTeamMemberTeamsTeamIdMembersPost(teamId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddTeamMemberTeamsTeamIdMembersPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addTeamMemberTeamsTeamIdMembersPost>>
>;
export type AddTeamMemberTeamsTeamIdMembersPostMutationBody = TeamMemberCreate;
export type AddTeamMemberTeamsTeamIdMembersPostMutationError =
  HTTPValidationError;

/**
 * @summary Add Team Member
 */
export const useAddTeamMemberTeamsTeamIdMembersPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addTeamMemberTeamsTeamIdMembersPost>>,
      TError,
      { teamId: string; data: TeamMemberCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addTeamMemberTeamsTeamIdMembersPost>>,
  TError,
  { teamId: string; data: TeamMemberCreate },
  TContext
> => {
  const mutationOptions =
    getAddTeamMemberTeamsTeamIdMembersPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of team members
 * @summary Get Team Members
 */
export const getTeamMembersTeamsTeamIdMembersGet = (
  teamId: string,
  params?: GetTeamMembersTeamsTeamIdMembersGetParams,
  signal?: AbortSignal,
) => {
  return api<TeamMemberResponse[]>({
    url: `https://api.atuna.org/teams/${teamId}/members`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetTeamMembersTeamsTeamIdMembersGetQueryKey = (
  teamId?: string,
  params?: GetTeamMembersTeamsTeamIdMembersGetParams,
) => {
  return [
    `https://api.atuna.org/teams/${teamId}/members`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetTeamMembersTeamsTeamIdMembersGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  params?: GetTeamMembersTeamsTeamIdMembersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTeamMembersTeamsTeamIdMembersGetQueryKey(teamId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>
  > = ({ signal }) =>
    getTeamMembersTeamsTeamIdMembersGet(teamId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamMembersTeamsTeamIdMembersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>
>;
export type GetTeamMembersTeamsTeamIdMembersGetQueryError = HTTPValidationError;

export function useGetTeamMembersTeamsTeamIdMembersGet<
  TData = Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  params: undefined | GetTeamMembersTeamsTeamIdMembersGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
          TError,
          Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamMembersTeamsTeamIdMembersGet<
  TData = Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  params?: GetTeamMembersTeamsTeamIdMembersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
          TError,
          Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamMembersTeamsTeamIdMembersGet<
  TData = Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  params?: GetTeamMembersTeamsTeamIdMembersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Team Members
 */

export function useGetTeamMembersTeamsTeamIdMembersGet<
  TData = Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
  TError = HTTPValidationError,
>(
  teamId: string,
  params?: GetTeamMembersTeamsTeamIdMembersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamMembersTeamsTeamIdMembersGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamMembersTeamsTeamIdMembersGetQueryOptions(
    teamId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get specific team member accomplishments and info
 * @summary Get Team Member Accomplishments
 */
export const getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet = (
  teamId: string,
  userId: string,
  signal?: AbortSignal,
) => {
  return api<AgentAccomplishmentsResponse>({
    url: `https://api.atuna.org/teams/${teamId}/members/${userId}`,
    method: "GET",
    signal,
  });
};

export const getGetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGetQueryKey =
  (teamId?: string, userId?: string) => {
    return [`https://api.atuna.org/teams/${teamId}/members/${userId}`] as const;
  };

export const getGetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet>
    >,
    TError = HTTPValidationError,
  >(
    teamId: string,
    userId: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGetQueryKey(
        teamId,
        userId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
        >
      >
    > = ({ signal }) =>
      getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet(
        teamId,
        userId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(teamId && userId),
      staleTime: 30000,
      refetchOnWindowFocus: false,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet>
    >
  >;
export type GetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGetQueryError =
  HTTPValidationError;

export function useGetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet<
  TData = Awaited<
    ReturnType<typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet>
  >,
  TError = HTTPValidationError,
>(
  teamId: string,
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet<
  TData = Awaited<
    ReturnType<typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet>
  >,
  TError = HTTPValidationError,
>(
  teamId: string,
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet<
  TData = Awaited<
    ReturnType<typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet>
  >,
  TError = HTTPValidationError,
>(
  teamId: string,
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Team Member Accomplishments
 */

export function useGetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet<
  TData = Awaited<
    ReturnType<typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet>
  >,
  TError = HTTPValidationError,
>(
  teamId: string,
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetTeamMemberAccomplishmentsTeamsTeamIdMembersUserIdGetQueryOptions(
      teamId,
      userId,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Remove team member
 * @summary Remove Team Member
 */
export const removeTeamMemberTeamsTeamIdMembersUserIdDelete = (
  teamId: string,
  userId: string,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/teams/${teamId}/members/${userId}`,
    method: "DELETE",
  });
};

export const getRemoveTeamMemberTeamsTeamIdMembersUserIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof removeTeamMemberTeamsTeamIdMembersUserIdDelete>
      >,
      TError,
      { teamId: string; userId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof removeTeamMemberTeamsTeamIdMembersUserIdDelete>>,
    TError,
    { teamId: string; userId: string },
    TContext
  > => {
    const mutationKey = ["removeTeamMemberTeamsTeamIdMembersUserIdDelete"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof removeTeamMemberTeamsTeamIdMembersUserIdDelete>
      >,
      { teamId: string; userId: string }
    > = (props) => {
      const { teamId, userId } = props ?? {};

      return removeTeamMemberTeamsTeamIdMembersUserIdDelete(teamId, userId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type RemoveTeamMemberTeamsTeamIdMembersUserIdDeleteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof removeTeamMemberTeamsTeamIdMembersUserIdDelete>>
  >;

export type RemoveTeamMemberTeamsTeamIdMembersUserIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Remove Team Member
 */
export const useRemoveTeamMemberTeamsTeamIdMembersUserIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof removeTeamMemberTeamsTeamIdMembersUserIdDelete>
      >,
      TError,
      { teamId: string; userId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeTeamMemberTeamsTeamIdMembersUserIdDelete>>,
  TError,
  { teamId: string; userId: string },
  TContext
> => {
  const mutationOptions =
    getRemoveTeamMemberTeamsTeamIdMembersUserIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of monthly events
 * @summary Get Monthly Events
 */
export const getMonthlyEventsEventsGet = (
  params?: GetMonthlyEventsEventsGetParams,
  signal?: AbortSignal,
) => {
  return api<EventResponse[]>({
    url: `https://api.atuna.org/events/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetMonthlyEventsEventsGetQueryKey = (
  params?: GetMonthlyEventsEventsGetParams,
) => {
  return [
    `https://api.atuna.org/events/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMonthlyEventsEventsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetMonthlyEventsEventsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMonthlyEventsEventsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>
  > = ({ signal }) => getMonthlyEventsEventsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthlyEventsEventsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>
>;
export type GetMonthlyEventsEventsGetQueryError = HTTPValidationError;

export function useGetMonthlyEventsEventsGet<
  TData = Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetMonthlyEventsEventsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
          TError,
          Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMonthlyEventsEventsGet<
  TData = Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetMonthlyEventsEventsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
          TError,
          Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMonthlyEventsEventsGet<
  TData = Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetMonthlyEventsEventsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Monthly Events
 */

export function useGetMonthlyEventsEventsGet<
  TData = Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetMonthlyEventsEventsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonthlyEventsEventsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMonthlyEventsEventsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new event (Admin, Broker, Agent only)
 * @summary Create Event
 */
export const createEventEventsPost = (
  eventCreate: EventCreate,
  signal?: AbortSignal,
) => {
  return api<EventResponse>({
    url: `https://api.atuna.org/events/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: eventCreate,
    signal,
  });
};

export const getCreateEventEventsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEventEventsPost>>,
    TError,
    { data: EventCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createEventEventsPost>>,
  TError,
  { data: EventCreate },
  TContext
> => {
  const mutationKey = ["createEventEventsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createEventEventsPost>>,
    { data: EventCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createEventEventsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateEventEventsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createEventEventsPost>>
>;
export type CreateEventEventsPostMutationBody = EventCreate;
export type CreateEventEventsPostMutationError = HTTPValidationError;

/**
 * @summary Create Event
 */
export const useCreateEventEventsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createEventEventsPost>>,
      TError,
      { data: EventCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createEventEventsPost>>,
  TError,
  { data: EventCreate },
  TContext
> => {
  const mutationOptions = getCreateEventEventsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get specific event details
 * @summary Get Event Details
 */
export const getEventDetailsEventsEventIdGet = (
  eventId: string,
  signal?: AbortSignal,
) => {
  return api<EventDetailResponse>({
    url: `https://api.atuna.org/events/${eventId}`,
    method: "GET",
    signal,
  });
};

export const getGetEventDetailsEventsEventIdGetQueryKey = (
  eventId?: string,
) => {
  return [`https://api.atuna.org/events/${eventId}`] as const;
};

export const getGetEventDetailsEventsEventIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
  TError = HTTPValidationError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetEventDetailsEventsEventIdGetQueryKey(eventId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>
  > = ({ signal }) => getEventDetailsEventsEventIdGet(eventId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEventDetailsEventsEventIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>
>;
export type GetEventDetailsEventsEventIdGetQueryError = HTTPValidationError;

export function useGetEventDetailsEventsEventIdGet<
  TData = Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
  TError = HTTPValidationError,
>(
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventDetailsEventsEventIdGet<
  TData = Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
  TError = HTTPValidationError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventDetailsEventsEventIdGet<
  TData = Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
  TError = HTTPValidationError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Event Details
 */

export function useGetEventDetailsEventsEventIdGet<
  TData = Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
  TError = HTTPValidationError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDetailsEventsEventIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventDetailsEventsEventIdGetQueryOptions(
    eventId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update event
 * @summary Update Event
 */
export const updateEventEventsEventIdPut = (
  eventId: string,
  eventUpdate: EventUpdate,
) => {
  return api<EventResponse>({
    url: `https://api.atuna.org/events/${eventId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: eventUpdate,
  });
};

export const getUpdateEventEventsEventIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateEventEventsEventIdPut>>,
    TError,
    { eventId: string; data: EventUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateEventEventsEventIdPut>>,
  TError,
  { eventId: string; data: EventUpdate },
  TContext
> => {
  const mutationKey = ["updateEventEventsEventIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateEventEventsEventIdPut>>,
    { eventId: string; data: EventUpdate }
  > = (props) => {
    const { eventId, data } = props ?? {};

    return updateEventEventsEventIdPut(eventId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateEventEventsEventIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateEventEventsEventIdPut>>
>;
export type UpdateEventEventsEventIdPutMutationBody = EventUpdate;
export type UpdateEventEventsEventIdPutMutationError = HTTPValidationError;

/**
 * @summary Update Event
 */
export const useUpdateEventEventsEventIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateEventEventsEventIdPut>>,
      TError,
      { eventId: string; data: EventUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateEventEventsEventIdPut>>,
  TError,
  { eventId: string; data: EventUpdate },
  TContext
> => {
  const mutationOptions =
    getUpdateEventEventsEventIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Cancel/archive event
 * @summary Cancel Event
 */
export const cancelEventEventsEventIdDelete = (eventId: string) => {
  return api<unknown>({
    url: `https://api.atuna.org/events/${eventId}`,
    method: "DELETE",
  });
};

export const getCancelEventEventsEventIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelEventEventsEventIdDelete>>,
    TError,
    { eventId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelEventEventsEventIdDelete>>,
  TError,
  { eventId: string },
  TContext
> => {
  const mutationKey = ["cancelEventEventsEventIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelEventEventsEventIdDelete>>,
    { eventId: string }
  > = (props) => {
    const { eventId } = props ?? {};

    return cancelEventEventsEventIdDelete(eventId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelEventEventsEventIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelEventEventsEventIdDelete>>
>;

export type CancelEventEventsEventIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Cancel Event
 */
export const useCancelEventEventsEventIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelEventEventsEventIdDelete>>,
      TError,
      { eventId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof cancelEventEventsEventIdDelete>>,
  TError,
  { eventId: string },
  TContext
> => {
  const mutationOptions =
    getCancelEventEventsEventIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of pending approval accounts (Admin only)
 * @summary Get Pending Accounts
 */
export const getPendingAccountsAccountsPendingGet = (
  params?: GetPendingAccountsAccountsPendingGetParams,
  signal?: AbortSignal,
) => {
  return api<UserPendingResponse[]>({
    url: `https://api.atuna.org/accounts/pending`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPendingAccountsAccountsPendingGetQueryKey = (
  params?: GetPendingAccountsAccountsPendingGetParams,
) => {
  return [
    `https://api.atuna.org/accounts/pending`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetPendingAccountsAccountsPendingGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPendingAccountsAccountsPendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPendingAccountsAccountsPendingGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>
  > = ({ signal }) => getPendingAccountsAccountsPendingGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingAccountsAccountsPendingGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>
>;
export type GetPendingAccountsAccountsPendingGetQueryError =
  HTTPValidationError;

export function useGetPendingAccountsAccountsPendingGet<
  TData = Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetPendingAccountsAccountsPendingGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
          TError,
          Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingAccountsAccountsPendingGet<
  TData = Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPendingAccountsAccountsPendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
          TError,
          Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingAccountsAccountsPendingGet<
  TData = Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPendingAccountsAccountsPendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Pending Accounts
 */

export function useGetPendingAccountsAccountsPendingGet<
  TData = Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPendingAccountsAccountsPendingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingAccountsAccountsPendingGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPendingAccountsAccountsPendingGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get paginated list of approved accounts (Admin only)
 * @summary Get Approved Accounts
 */
export const getApprovedAccountsAccountsApprovedGet = (
  params?: GetApprovedAccountsAccountsApprovedGetParams,
  signal?: AbortSignal,
) => {
  return api<UserResponse[]>({
    url: `https://api.atuna.org/accounts/approved`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetApprovedAccountsAccountsApprovedGetQueryKey = (
  params?: GetApprovedAccountsAccountsApprovedGetParams,
) => {
  return [
    `https://api.atuna.org/accounts/approved`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetApprovedAccountsAccountsApprovedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetApprovedAccountsAccountsApprovedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetApprovedAccountsAccountsApprovedGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>
  > = ({ signal }) => getApprovedAccountsAccountsApprovedGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApprovedAccountsAccountsApprovedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>
>;
export type GetApprovedAccountsAccountsApprovedGetQueryError =
  HTTPValidationError;

export function useGetApprovedAccountsAccountsApprovedGet<
  TData = Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetApprovedAccountsAccountsApprovedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
          TError,
          Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApprovedAccountsAccountsApprovedGet<
  TData = Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetApprovedAccountsAccountsApprovedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
          TError,
          Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApprovedAccountsAccountsApprovedGet<
  TData = Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetApprovedAccountsAccountsApprovedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Approved Accounts
 */

export function useGetApprovedAccountsAccountsApprovedGet<
  TData = Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetApprovedAccountsAccountsApprovedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApprovedAccountsAccountsApprovedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApprovedAccountsAccountsApprovedGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Approve account (Admin only)
 * @summary Approve Account
 */
export const approveAccountAccountsApproveUserIdPut = (userId: string) => {
  return api<unknown>({
    url: `https://api.atuna.org/accounts/approve/${userId}`,
    method: "PUT",
  });
};

export const getApproveAccountAccountsApproveUserIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof approveAccountAccountsApproveUserIdPut>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof approveAccountAccountsApproveUserIdPut>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationKey = ["approveAccountAccountsApproveUserIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof approveAccountAccountsApproveUserIdPut>>,
    { userId: string }
  > = (props) => {
    const { userId } = props ?? {};

    return approveAccountAccountsApproveUserIdPut(userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApproveAccountAccountsApproveUserIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof approveAccountAccountsApproveUserIdPut>>
>;

export type ApproveAccountAccountsApproveUserIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Approve Account
 */
export const useApproveAccountAccountsApproveUserIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof approveAccountAccountsApproveUserIdPut>>,
      TError,
      { userId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof approveAccountAccountsApproveUserIdPut>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions =
    getApproveAccountAccountsApproveUserIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of rejected accounts (Admin only)
 * @summary Get Rejected Accounts
 */
export const getRejectedAccountsAccountsRejectedGet = (
  params?: GetRejectedAccountsAccountsRejectedGetParams,
  signal?: AbortSignal,
) => {
  return api<UserResponse[]>({
    url: `https://api.atuna.org/accounts/rejected`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRejectedAccountsAccountsRejectedGetQueryKey = (
  params?: GetRejectedAccountsAccountsRejectedGetParams,
) => {
  return [
    `https://api.atuna.org/accounts/rejected`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetRejectedAccountsAccountsRejectedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRejectedAccountsAccountsRejectedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetRejectedAccountsAccountsRejectedGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>
  > = ({ signal }) => getRejectedAccountsAccountsRejectedGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRejectedAccountsAccountsRejectedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>
>;
export type GetRejectedAccountsAccountsRejectedGetQueryError =
  HTTPValidationError;

export function useGetRejectedAccountsAccountsRejectedGet<
  TData = Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetRejectedAccountsAccountsRejectedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
          TError,
          Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRejectedAccountsAccountsRejectedGet<
  TData = Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRejectedAccountsAccountsRejectedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
          TError,
          Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRejectedAccountsAccountsRejectedGet<
  TData = Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRejectedAccountsAccountsRejectedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Rejected Accounts
 */

export function useGetRejectedAccountsAccountsRejectedGet<
  TData = Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRejectedAccountsAccountsRejectedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRejectedAccountsAccountsRejectedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRejectedAccountsAccountsRejectedGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Reject account with reason (Admin only)
 * @summary Reject Account
 */
export const rejectAccountAccountsRejectUserIdPut = (
  userId: string,
  accountRejection: AccountRejection,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/accounts/reject/${userId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: accountRejection,
  });
};

export const getRejectAccountAccountsRejectUserIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rejectAccountAccountsRejectUserIdPut>>,
    TError,
    { userId: string; data: AccountRejection },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rejectAccountAccountsRejectUserIdPut>>,
  TError,
  { userId: string; data: AccountRejection },
  TContext
> => {
  const mutationKey = ["rejectAccountAccountsRejectUserIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rejectAccountAccountsRejectUserIdPut>>,
    { userId: string; data: AccountRejection }
  > = (props) => {
    const { userId, data } = props ?? {};

    return rejectAccountAccountsRejectUserIdPut(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RejectAccountAccountsRejectUserIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof rejectAccountAccountsRejectUserIdPut>>
>;
export type RejectAccountAccountsRejectUserIdPutMutationBody = AccountRejection;
export type RejectAccountAccountsRejectUserIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Reject Account
 */
export const useRejectAccountAccountsRejectUserIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rejectAccountAccountsRejectUserIdPut>>,
      TError,
      { userId: string; data: AccountRejection },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof rejectAccountAccountsRejectUserIdPut>>,
  TError,
  { userId: string; data: AccountRejection },
  TContext
> => {
  const mutationOptions =
    getRejectAccountAccountsRejectUserIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of banned accounts (Admin only)
 * @summary Get Banned Accounts
 */
export const getBannedAccountsAccountsBannedGet = (
  params?: GetBannedAccountsAccountsBannedGetParams,
  signal?: AbortSignal,
) => {
  return api<UserResponse[]>({
    url: `https://api.atuna.org/accounts/banned`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetBannedAccountsAccountsBannedGetQueryKey = (
  params?: GetBannedAccountsAccountsBannedGetParams,
) => {
  return [
    `https://api.atuna.org/accounts/banned`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetBannedAccountsAccountsBannedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBannedAccountsAccountsBannedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBannedAccountsAccountsBannedGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>
  > = ({ signal }) => getBannedAccountsAccountsBannedGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBannedAccountsAccountsBannedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>
>;
export type GetBannedAccountsAccountsBannedGetQueryError = HTTPValidationError;

export function useGetBannedAccountsAccountsBannedGet<
  TData = Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetBannedAccountsAccountsBannedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
          TError,
          Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBannedAccountsAccountsBannedGet<
  TData = Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBannedAccountsAccountsBannedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
          TError,
          Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBannedAccountsAccountsBannedGet<
  TData = Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBannedAccountsAccountsBannedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Banned Accounts
 */

export function useGetBannedAccountsAccountsBannedGet<
  TData = Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBannedAccountsAccountsBannedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBannedAccountsAccountsBannedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetBannedAccountsAccountsBannedGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ban account (Admin only)
 * @summary Ban Account
 */
export const banAccountAccountsBanUserIdPut = (
  userId: string,
  accountBan: AccountBan,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/accounts/ban/${userId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: accountBan,
  });
};

export const getBanAccountAccountsBanUserIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof banAccountAccountsBanUserIdPut>>,
    TError,
    { userId: string; data: AccountBan },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof banAccountAccountsBanUserIdPut>>,
  TError,
  { userId: string; data: AccountBan },
  TContext
> => {
  const mutationKey = ["banAccountAccountsBanUserIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof banAccountAccountsBanUserIdPut>>,
    { userId: string; data: AccountBan }
  > = (props) => {
    const { userId, data } = props ?? {};

    return banAccountAccountsBanUserIdPut(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type BanAccountAccountsBanUserIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof banAccountAccountsBanUserIdPut>>
>;
export type BanAccountAccountsBanUserIdPutMutationBody = AccountBan;
export type BanAccountAccountsBanUserIdPutMutationError = HTTPValidationError;

/**
 * @summary Ban Account
 */
export const useBanAccountAccountsBanUserIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof banAccountAccountsBanUserIdPut>>,
      TError,
      { userId: string; data: AccountBan },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof banAccountAccountsBanUserIdPut>>,
  TError,
  { userId: string; data: AccountBan },
  TContext
> => {
  const mutationOptions =
    getBanAccountAccountsBanUserIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Unban account (Admin only)
 * @summary Unban Account
 */
export const unbanAccountAccountsUnbanUserIdPut = (userId: string) => {
  return api<unknown>({
    url: `https://api.atuna.org/accounts/unban/${userId}`,
    method: "PUT",
  });
};

export const getUnbanAccountAccountsUnbanUserIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unbanAccountAccountsUnbanUserIdPut>>,
    TError,
    { userId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unbanAccountAccountsUnbanUserIdPut>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationKey = ["unbanAccountAccountsUnbanUserIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unbanAccountAccountsUnbanUserIdPut>>,
    { userId: string }
  > = (props) => {
    const { userId } = props ?? {};

    return unbanAccountAccountsUnbanUserIdPut(userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnbanAccountAccountsUnbanUserIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof unbanAccountAccountsUnbanUserIdPut>>
>;

export type UnbanAccountAccountsUnbanUserIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Unban Account
 */
export const useUnbanAccountAccountsUnbanUserIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unbanAccountAccountsUnbanUserIdPut>>,
      TError,
      { userId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unbanAccountAccountsUnbanUserIdPut>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions =
    getUnbanAccountAccountsUnbanUserIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of deleted accounts (Admin only)
 * @summary Get Deleted Accounts
 */
export const getDeletedAccountsAccountsDeletedGet = (
  params?: GetDeletedAccountsAccountsDeletedGetParams,
  signal?: AbortSignal,
) => {
  return api<UserResponse[]>({
    url: `https://api.atuna.org/accounts/deleted`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDeletedAccountsAccountsDeletedGetQueryKey = (
  params?: GetDeletedAccountsAccountsDeletedGetParams,
) => {
  return [
    `https://api.atuna.org/accounts/deleted`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetDeletedAccountsAccountsDeletedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDeletedAccountsAccountsDeletedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetDeletedAccountsAccountsDeletedGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>
  > = ({ signal }) => getDeletedAccountsAccountsDeletedGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDeletedAccountsAccountsDeletedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>
>;
export type GetDeletedAccountsAccountsDeletedGetQueryError =
  HTTPValidationError;

export function useGetDeletedAccountsAccountsDeletedGet<
  TData = Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetDeletedAccountsAccountsDeletedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
          TError,
          Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDeletedAccountsAccountsDeletedGet<
  TData = Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDeletedAccountsAccountsDeletedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
          TError,
          Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDeletedAccountsAccountsDeletedGet<
  TData = Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDeletedAccountsAccountsDeletedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Deleted Accounts
 */

export function useGetDeletedAccountsAccountsDeletedGet<
  TData = Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDeletedAccountsAccountsDeletedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeletedAccountsAccountsDeletedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDeletedAccountsAccountsDeletedGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get dashboard analytics (Admin, Developer, Broker only)
 * @summary Get Dashboard Analytics
 */
export const getDashboardAnalyticsAnalyticsDashboardGet = (
  signal?: AbortSignal,
) => {
  return api<DashboardAnalytics>({
    url: `https://api.atuna.org/analytics/dashboard`,
    method: "GET",
    signal,
  });
};

export const getGetDashboardAnalyticsAnalyticsDashboardGetQueryKey = () => {
  return [`https://api.atuna.org/analytics/dashboard`] as const;
};

export const getGetDashboardAnalyticsAnalyticsDashboardGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetDashboardAnalyticsAnalyticsDashboardGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>
  > = ({ signal }) => getDashboardAnalyticsAnalyticsDashboardGet(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDashboardAnalyticsAnalyticsDashboardGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>
>;
export type GetDashboardAnalyticsAnalyticsDashboardGetQueryError = unknown;

export function useGetDashboardAnalyticsAnalyticsDashboardGet<
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>
          >,
          TError,
          Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDashboardAnalyticsAnalyticsDashboardGet<
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>
          >,
          TError,
          Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDashboardAnalyticsAnalyticsDashboardGet<
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Dashboard Analytics
 */

export function useGetDashboardAnalyticsAnalyticsDashboardGet<
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardAnalyticsAnalyticsDashboardGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetDashboardAnalyticsAnalyticsDashboardGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get sales analytics
 * @summary Get Sales Analytics
 */
export const getSalesAnalyticsAnalyticsSalesGet = (
  params?: GetSalesAnalyticsAnalyticsSalesGetParams,
  signal?: AbortSignal,
) => {
  return api<SalesAnalytics>({
    url: `https://api.atuna.org/analytics/sales`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSalesAnalyticsAnalyticsSalesGetQueryKey = (
  params?: GetSalesAnalyticsAnalyticsSalesGetParams,
) => {
  return [
    `https://api.atuna.org/analytics/sales`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSalesAnalyticsAnalyticsSalesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesAnalyticsAnalyticsSalesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSalesAnalyticsAnalyticsSalesGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>
  > = ({ signal }) => getSalesAnalyticsAnalyticsSalesGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSalesAnalyticsAnalyticsSalesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>
>;
export type GetSalesAnalyticsAnalyticsSalesGetQueryError = HTTPValidationError;

export function useGetSalesAnalyticsAnalyticsSalesGet<
  TData = Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetSalesAnalyticsAnalyticsSalesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
          TError,
          Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSalesAnalyticsAnalyticsSalesGet<
  TData = Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesAnalyticsAnalyticsSalesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
          TError,
          Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSalesAnalyticsAnalyticsSalesGet<
  TData = Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesAnalyticsAnalyticsSalesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Sales Analytics
 */

export function useGetSalesAnalyticsAnalyticsSalesGet<
  TData = Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesAnalyticsAnalyticsSalesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsAnalyticsSalesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSalesAnalyticsAnalyticsSalesGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get leads analytics
 * @summary Get Leads Analytics
 */
export const getLeadsAnalyticsAnalyticsLeadsGet = (
  params?: GetLeadsAnalyticsAnalyticsLeadsGetParams,
  signal?: AbortSignal,
) => {
  return api<LeadsAnalytics>({
    url: `https://api.atuna.org/analytics/leads`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLeadsAnalyticsAnalyticsLeadsGetQueryKey = (
  params?: GetLeadsAnalyticsAnalyticsLeadsGetParams,
) => {
  return [
    `https://api.atuna.org/analytics/leads`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLeadsAnalyticsAnalyticsLeadsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsAnalyticsAnalyticsLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetLeadsAnalyticsAnalyticsLeadsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>
  > = ({ signal }) => getLeadsAnalyticsAnalyticsLeadsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLeadsAnalyticsAnalyticsLeadsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>
>;
export type GetLeadsAnalyticsAnalyticsLeadsGetQueryError = HTTPValidationError;

export function useGetLeadsAnalyticsAnalyticsLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetLeadsAnalyticsAnalyticsLeadsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
          TError,
          Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeadsAnalyticsAnalyticsLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsAnalyticsAnalyticsLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
          TError,
          Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeadsAnalyticsAnalyticsLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsAnalyticsAnalyticsLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Leads Analytics
 */

export function useGetLeadsAnalyticsAnalyticsLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsAnalyticsAnalyticsLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetLeadsAnalyticsAnalyticsLeadsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get inventory analytics (Developer only)
 * @summary Get Inventory Analytics
 */
export const getInventoryAnalyticsAnalyticsInventoryGet = (
  params?: GetInventoryAnalyticsAnalyticsInventoryGetParams,
  signal?: AbortSignal,
) => {
  return api<InventoryAnalytics>({
    url: `https://api.atuna.org/analytics/inventory`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetInventoryAnalyticsAnalyticsInventoryGetQueryKey = (
  params?: GetInventoryAnalyticsAnalyticsInventoryGetParams,
) => {
  return [
    `https://api.atuna.org/analytics/inventory`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetInventoryAnalyticsAnalyticsInventoryGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetInventoryAnalyticsAnalyticsInventoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetInventoryAnalyticsAnalyticsInventoryGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>
  > = ({ signal }) =>
    getInventoryAnalyticsAnalyticsInventoryGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInventoryAnalyticsAnalyticsInventoryGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>
>;
export type GetInventoryAnalyticsAnalyticsInventoryGetQueryError =
  HTTPValidationError;

export function useGetInventoryAnalyticsAnalyticsInventoryGet<
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>
  >,
  TError = HTTPValidationError,
>(
  params: undefined | GetInventoryAnalyticsAnalyticsInventoryGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>
          >,
          TError,
          Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInventoryAnalyticsAnalyticsInventoryGet<
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetInventoryAnalyticsAnalyticsInventoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>
          >,
          TError,
          Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInventoryAnalyticsAnalyticsInventoryGet<
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetInventoryAnalyticsAnalyticsInventoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Inventory Analytics
 */

export function useGetInventoryAnalyticsAnalyticsInventoryGet<
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetInventoryAnalyticsAnalyticsInventoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryAnalyticsAnalyticsInventoryGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetInventoryAnalyticsAnalyticsInventoryGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get agent performance analytics
 * @summary Get Agent Performance
 */
export const getAgentPerformanceAnalyticsAgentPerformanceGet = (
  params?: GetAgentPerformanceAnalyticsAgentPerformanceGetParams,
  signal?: AbortSignal,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/analytics/agent-performance`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetAgentPerformanceAnalyticsAgentPerformanceGetQueryKey = (
  params?: GetAgentPerformanceAnalyticsAgentPerformanceGetParams,
) => {
  return [
    `https://api.atuna.org/analytics/agent-performance`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAgentPerformanceAnalyticsAgentPerformanceGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetAgentPerformanceAnalyticsAgentPerformanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAgentPerformanceAnalyticsAgentPerformanceGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>>
  > = ({ signal }) =>
    getAgentPerformanceAnalyticsAgentPerformanceGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAgentPerformanceAnalyticsAgentPerformanceGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>>
  >;
export type GetAgentPerformanceAnalyticsAgentPerformanceGetQueryError =
  HTTPValidationError;

export function useGetAgentPerformanceAnalyticsAgentPerformanceGet<
  TData = Awaited<
    ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params: undefined | GetAgentPerformanceAnalyticsAgentPerformanceGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAgentPerformanceAnalyticsAgentPerformanceGet<
  TData = Awaited<
    ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetAgentPerformanceAnalyticsAgentPerformanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAgentPerformanceAnalyticsAgentPerformanceGet<
  TData = Awaited<
    ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetAgentPerformanceAnalyticsAgentPerformanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Agent Performance
 */

export function useGetAgentPerformanceAnalyticsAgentPerformanceGet<
  TData = Awaited<
    ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetAgentPerformanceAnalyticsAgentPerformanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getAgentPerformanceAnalyticsAgentPerformanceGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetAgentPerformanceAnalyticsAgentPerformanceGetQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get revenue analytics
 * @summary Get Revenue Analytics
 */
export const getRevenueAnalyticsAnalyticsRevenueGet = (
  params?: GetRevenueAnalyticsAnalyticsRevenueGetParams,
  signal?: AbortSignal,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/analytics/revenue`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRevenueAnalyticsAnalyticsRevenueGetQueryKey = (
  params?: GetRevenueAnalyticsAnalyticsRevenueGetParams,
) => {
  return [
    `https://api.atuna.org/analytics/revenue`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetRevenueAnalyticsAnalyticsRevenueGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRevenueAnalyticsAnalyticsRevenueGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetRevenueAnalyticsAnalyticsRevenueGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>
  > = ({ signal }) => getRevenueAnalyticsAnalyticsRevenueGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRevenueAnalyticsAnalyticsRevenueGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>
>;
export type GetRevenueAnalyticsAnalyticsRevenueGetQueryError =
  HTTPValidationError;

export function useGetRevenueAnalyticsAnalyticsRevenueGet<
  TData = Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetRevenueAnalyticsAnalyticsRevenueGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
          TError,
          Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRevenueAnalyticsAnalyticsRevenueGet<
  TData = Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRevenueAnalyticsAnalyticsRevenueGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
          TError,
          Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRevenueAnalyticsAnalyticsRevenueGet<
  TData = Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRevenueAnalyticsAnalyticsRevenueGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Revenue Analytics
 */

export function useGetRevenueAnalyticsAnalyticsRevenueGet<
  TData = Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRevenueAnalyticsAnalyticsRevenueGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRevenueAnalyticsAnalyticsRevenueGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRevenueAnalyticsAnalyticsRevenueGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get conversion funnel analytics
 * @summary Get Conversion Funnel
 */
export const getConversionFunnelAnalyticsConversionFunnelGet = (
  params?: GetConversionFunnelAnalyticsConversionFunnelGetParams,
  signal?: AbortSignal,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/analytics/conversion-funnel`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetConversionFunnelAnalyticsConversionFunnelGetQueryKey = (
  params?: GetConversionFunnelAnalyticsConversionFunnelGetParams,
) => {
  return [
    `https://api.atuna.org/analytics/conversion-funnel`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetConversionFunnelAnalyticsConversionFunnelGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetConversionFunnelAnalyticsConversionFunnelGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetConversionFunnelAnalyticsConversionFunnelGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>>
  > = ({ signal }) =>
    getConversionFunnelAnalyticsConversionFunnelGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConversionFunnelAnalyticsConversionFunnelGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>>
  >;
export type GetConversionFunnelAnalyticsConversionFunnelGetQueryError =
  HTTPValidationError;

export function useGetConversionFunnelAnalyticsConversionFunnelGet<
  TData = Awaited<
    ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
  >,
  TError = HTTPValidationError,
>(
  params: undefined | GetConversionFunnelAnalyticsConversionFunnelGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetConversionFunnelAnalyticsConversionFunnelGet<
  TData = Awaited<
    ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetConversionFunnelAnalyticsConversionFunnelGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetConversionFunnelAnalyticsConversionFunnelGet<
  TData = Awaited<
    ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetConversionFunnelAnalyticsConversionFunnelGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Conversion Funnel
 */

export function useGetConversionFunnelAnalyticsConversionFunnelGet<
  TData = Awaited<
    ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetConversionFunnelAnalyticsConversionFunnelGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getConversionFunnelAnalyticsConversionFunnelGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetConversionFunnelAnalyticsConversionFunnelGetQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get property performance analytics
 * @summary Get Property Performance
 */
export const getPropertyPerformanceAnalyticsPropertyPerformanceGet = (
  params?: GetPropertyPerformanceAnalyticsPropertyPerformanceGetParams,
  signal?: AbortSignal,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/analytics/property-performance`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPropertyPerformanceAnalyticsPropertyPerformanceGetQueryKey =
  (params?: GetPropertyPerformanceAnalyticsPropertyPerformanceGetParams) => {
    return [
      `https://api.atuna.org/analytics/property-performance`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getGetPropertyPerformanceAnalyticsPropertyPerformanceGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet>
    >,
    TError = HTTPValidationError,
  >(
    params?: GetPropertyPerformanceAnalyticsPropertyPerformanceGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetPropertyPerformanceAnalyticsPropertyPerformanceGetQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet>
      >
    > = ({ signal }) =>
      getPropertyPerformanceAnalyticsPropertyPerformanceGet(params, signal);

    return {
      queryKey,
      queryFn,
      staleTime: 30000,
      refetchOnWindowFocus: false,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetPropertyPerformanceAnalyticsPropertyPerformanceGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet>
    >
  >;
export type GetPropertyPerformanceAnalyticsPropertyPerformanceGetQueryError =
  HTTPValidationError;

export function useGetPropertyPerformanceAnalyticsPropertyPerformanceGet<
  TData = Awaited<
    ReturnType<typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params:
    | undefined
    | GetPropertyPerformanceAnalyticsPropertyPerformanceGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPropertyPerformanceAnalyticsPropertyPerformanceGet<
  TData = Awaited<
    ReturnType<typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetPropertyPerformanceAnalyticsPropertyPerformanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPropertyPerformanceAnalyticsPropertyPerformanceGet<
  TData = Awaited<
    ReturnType<typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetPropertyPerformanceAnalyticsPropertyPerformanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Property Performance
 */

export function useGetPropertyPerformanceAnalyticsPropertyPerformanceGet<
  TData = Awaited<
    ReturnType<typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetPropertyPerformanceAnalyticsPropertyPerformanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPropertyPerformanceAnalyticsPropertyPerformanceGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetPropertyPerformanceAnalyticsPropertyPerformanceGetQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Register a new client
 * @summary Register Client
 */
export const registerClientRegisterClientPost = (
  clientRegister: ClientRegister,
  signal?: AbortSignal,
) => {
  return api<UserResponse>({
    url: `https://api.atuna.org/register/client`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: clientRegister,
    signal,
  });
};

export const getRegisterClientRegisterClientPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerClientRegisterClientPost>>,
    TError,
    { data: ClientRegister },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerClientRegisterClientPost>>,
  TError,
  { data: ClientRegister },
  TContext
> => {
  const mutationKey = ["registerClientRegisterClientPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerClientRegisterClientPost>>,
    { data: ClientRegister }
  > = (props) => {
    const { data } = props ?? {};

    return registerClientRegisterClientPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterClientRegisterClientPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerClientRegisterClientPost>>
>;
export type RegisterClientRegisterClientPostMutationBody = ClientRegister;
export type RegisterClientRegisterClientPostMutationError = HTTPValidationError;

/**
 * @summary Register Client
 */
export const useRegisterClientRegisterClientPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof registerClientRegisterClientPost>>,
      TError,
      { data: ClientRegister },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof registerClientRegisterClientPost>>,
  TError,
  { data: ClientRegister },
  TContext
> => {
  const mutationOptions =
    getRegisterClientRegisterClientPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Register a new developer
 * @summary Register Developer
 */
export const registerDeveloperRegisterDeveloperPost = (
  developerRegister: DeveloperRegister,
  signal?: AbortSignal,
) => {
  return api<DeveloperResponse>({
    url: `https://api.atuna.org/register/developer`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: developerRegister,
    signal,
  });
};

export const getRegisterDeveloperRegisterDeveloperPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerDeveloperRegisterDeveloperPost>>,
    TError,
    { data: DeveloperRegister },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerDeveloperRegisterDeveloperPost>>,
  TError,
  { data: DeveloperRegister },
  TContext
> => {
  const mutationKey = ["registerDeveloperRegisterDeveloperPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerDeveloperRegisterDeveloperPost>>,
    { data: DeveloperRegister }
  > = (props) => {
    const { data } = props ?? {};

    return registerDeveloperRegisterDeveloperPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterDeveloperRegisterDeveloperPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerDeveloperRegisterDeveloperPost>>
>;
export type RegisterDeveloperRegisterDeveloperPostMutationBody =
  DeveloperRegister;
export type RegisterDeveloperRegisterDeveloperPostMutationError =
  HTTPValidationError;

/**
 * @summary Register Developer
 */
export const useRegisterDeveloperRegisterDeveloperPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof registerDeveloperRegisterDeveloperPost>>,
      TError,
      { data: DeveloperRegister },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof registerDeveloperRegisterDeveloperPost>>,
  TError,
  { data: DeveloperRegister },
  TContext
> => {
  const mutationOptions =
    getRegisterDeveloperRegisterDeveloperPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Register a new broker
 * @summary Register Broker
 */
export const registerBrokerRegisterBrokerPost = (
  brokerRegister: BrokerRegister,
  signal?: AbortSignal,
) => {
  return api<BrokerResponse>({
    url: `https://api.atuna.org/register/broker`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: brokerRegister,
    signal,
  });
};

export const getRegisterBrokerRegisterBrokerPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerBrokerRegisterBrokerPost>>,
    TError,
    { data: BrokerRegister },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerBrokerRegisterBrokerPost>>,
  TError,
  { data: BrokerRegister },
  TContext
> => {
  const mutationKey = ["registerBrokerRegisterBrokerPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerBrokerRegisterBrokerPost>>,
    { data: BrokerRegister }
  > = (props) => {
    const { data } = props ?? {};

    return registerBrokerRegisterBrokerPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterBrokerRegisterBrokerPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerBrokerRegisterBrokerPost>>
>;
export type RegisterBrokerRegisterBrokerPostMutationBody = BrokerRegister;
export type RegisterBrokerRegisterBrokerPostMutationError = HTTPValidationError;

/**
 * @summary Register Broker
 */
export const useRegisterBrokerRegisterBrokerPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof registerBrokerRegisterBrokerPost>>,
      TError,
      { data: BrokerRegister },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof registerBrokerRegisterBrokerPost>>,
  TError,
  { data: BrokerRegister },
  TContext
> => {
  const mutationOptions =
    getRegisterBrokerRegisterBrokerPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Register a new agent
 * @summary Register Agent
 */
export const registerAgentRegisterAgentPost = (
  agentRegister: AgentRegister,
  signal?: AbortSignal,
) => {
  return api<AgentResponse>({
    url: `https://api.atuna.org/register/agent`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: agentRegister,
    signal,
  });
};

export const getRegisterAgentRegisterAgentPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerAgentRegisterAgentPost>>,
    TError,
    { data: AgentRegister },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerAgentRegisterAgentPost>>,
  TError,
  { data: AgentRegister },
  TContext
> => {
  const mutationKey = ["registerAgentRegisterAgentPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerAgentRegisterAgentPost>>,
    { data: AgentRegister }
  > = (props) => {
    const { data } = props ?? {};

    return registerAgentRegisterAgentPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterAgentRegisterAgentPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerAgentRegisterAgentPost>>
>;
export type RegisterAgentRegisterAgentPostMutationBody = AgentRegister;
export type RegisterAgentRegisterAgentPostMutationError = HTTPValidationError;

/**
 * @summary Register Agent
 */
export const useRegisterAgentRegisterAgentPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof registerAgentRegisterAgentPost>>,
      TError,
      { data: AgentRegister },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof registerAgentRegisterAgentPost>>,
  TError,
  { data: AgentRegister },
  TContext
> => {
  const mutationOptions =
    getRegisterAgentRegisterAgentPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new property
 * @summary Create Property
 */
export const createPropertyPropertiesPost = (
  propertyCreate: PropertyCreate,
  signal?: AbortSignal,
) => {
  return api<PropertyResponse>({
    url: `https://api.atuna.org/properties/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: propertyCreate,
    signal,
  });
};

export const getCreatePropertyPropertiesPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPropertyPropertiesPost>>,
    TError,
    { data: PropertyCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPropertyPropertiesPost>>,
  TError,
  { data: PropertyCreate },
  TContext
> => {
  const mutationKey = ["createPropertyPropertiesPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPropertyPropertiesPost>>,
    { data: PropertyCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createPropertyPropertiesPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePropertyPropertiesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPropertyPropertiesPost>>
>;
export type CreatePropertyPropertiesPostMutationBody = PropertyCreate;
export type CreatePropertyPropertiesPostMutationError = HTTPValidationError;

/**
 * @summary Create Property
 */
export const useCreatePropertyPropertiesPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPropertyPropertiesPost>>,
      TError,
      { data: PropertyCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createPropertyPropertiesPost>>,
  TError,
  { data: PropertyCreate },
  TContext
> => {
  const mutationOptions =
    getCreatePropertyPropertiesPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get paginated list of properties with filters
 * @summary Get Properties
 */
export const getPropertiesPropertiesGet = (
  params?: GetPropertiesPropertiesGetParams,
  signal?: AbortSignal,
) => {
  return api<PaginatedResponse>({
    url: `https://api.atuna.org/properties/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPropertiesPropertiesGetQueryKey = (
  params?: GetPropertiesPropertiesGetParams,
) => {
  return [
    `https://api.atuna.org/properties/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetPropertiesPropertiesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPropertiesPropertiesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPropertiesPropertiesGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPropertiesPropertiesGet>>
  > = ({ signal }) => getPropertiesPropertiesGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPropertiesPropertiesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPropertiesPropertiesGet>>
>;
export type GetPropertiesPropertiesGetQueryError = HTTPValidationError;

export function useGetPropertiesPropertiesGet<
  TData = Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetPropertiesPropertiesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
          TError,
          Awaited<ReturnType<typeof getPropertiesPropertiesGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPropertiesPropertiesGet<
  TData = Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPropertiesPropertiesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
          TError,
          Awaited<ReturnType<typeof getPropertiesPropertiesGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPropertiesPropertiesGet<
  TData = Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPropertiesPropertiesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Properties
 */

export function useGetPropertiesPropertiesGet<
  TData = Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPropertiesPropertiesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertiesPropertiesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPropertiesPropertiesGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create multiple properties from bulk data
 * @summary Create Properties Bulk
 */
export const createPropertiesBulkPropertiesBulkPost = (
  propertyBulkCreate: PropertyBulkCreate,
  signal?: AbortSignal,
) => {
  return api<CSVUploadResponse>({
    url: `https://api.atuna.org/properties/bulk`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: propertyBulkCreate,
    signal,
  });
};

export const getCreatePropertiesBulkPropertiesBulkPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPropertiesBulkPropertiesBulkPost>>,
    TError,
    { data: PropertyBulkCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPropertiesBulkPropertiesBulkPost>>,
  TError,
  { data: PropertyBulkCreate },
  TContext
> => {
  const mutationKey = ["createPropertiesBulkPropertiesBulkPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPropertiesBulkPropertiesBulkPost>>,
    { data: PropertyBulkCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createPropertiesBulkPropertiesBulkPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePropertiesBulkPropertiesBulkPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPropertiesBulkPropertiesBulkPost>>
>;
export type CreatePropertiesBulkPropertiesBulkPostMutationBody =
  PropertyBulkCreate;
export type CreatePropertiesBulkPropertiesBulkPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Properties Bulk
 */
export const useCreatePropertiesBulkPropertiesBulkPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPropertiesBulkPropertiesBulkPost>>,
      TError,
      { data: PropertyBulkCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createPropertiesBulkPropertiesBulkPost>>,
  TError,
  { data: PropertyBulkCreate },
  TContext
> => {
  const mutationOptions =
    getCreatePropertiesBulkPropertiesBulkPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Upload properties from CSV file
 * @summary Upload Properties Csv
 */
export const uploadPropertiesCsvPropertiesUploadCsvPost = (
  bodyUploadPropertiesCsvPropertiesUploadCsvPost: BodyUploadPropertiesCsvPropertiesUploadCsvPost,
  params?: UploadPropertiesCsvPropertiesUploadCsvPostParams,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append(`file`, bodyUploadPropertiesCsvPropertiesUploadCsvPost.file);

  return api<CSVUploadResponse>({
    url: `https://api.atuna.org/properties/upload-csv`,
    method: "POST",
    headers: { "Content-Type": "multipart/form-data" },
    data: formData,
    params,
    signal,
  });
};

export const getUploadPropertiesCsvPropertiesUploadCsvPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadPropertiesCsvPropertiesUploadCsvPost>>,
    TError,
    {
      data: BodyUploadPropertiesCsvPropertiesUploadCsvPost;
      params?: UploadPropertiesCsvPropertiesUploadCsvPostParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadPropertiesCsvPropertiesUploadCsvPost>>,
  TError,
  {
    data: BodyUploadPropertiesCsvPropertiesUploadCsvPost;
    params?: UploadPropertiesCsvPropertiesUploadCsvPostParams;
  },
  TContext
> => {
  const mutationKey = ["uploadPropertiesCsvPropertiesUploadCsvPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadPropertiesCsvPropertiesUploadCsvPost>>,
    {
      data: BodyUploadPropertiesCsvPropertiesUploadCsvPost;
      params?: UploadPropertiesCsvPropertiesUploadCsvPostParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return uploadPropertiesCsvPropertiesUploadCsvPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadPropertiesCsvPropertiesUploadCsvPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof uploadPropertiesCsvPropertiesUploadCsvPost>>
  >;
export type UploadPropertiesCsvPropertiesUploadCsvPostMutationBody =
  BodyUploadPropertiesCsvPropertiesUploadCsvPost;
export type UploadPropertiesCsvPropertiesUploadCsvPostMutationError =
  HTTPValidationError;

/**
 * @summary Upload Properties Csv
 */
export const useUploadPropertiesCsvPropertiesUploadCsvPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadPropertiesCsvPropertiesUploadCsvPost>>,
      TError,
      {
        data: BodyUploadPropertiesCsvPropertiesUploadCsvPost;
        params?: UploadPropertiesCsvPropertiesUploadCsvPostParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadPropertiesCsvPropertiesUploadCsvPost>>,
  TError,
  {
    data: BodyUploadPropertiesCsvPropertiesUploadCsvPost;
    params?: UploadPropertiesCsvPropertiesUploadCsvPostParams;
  },
  TContext
> => {
  const mutationOptions =
    getUploadPropertiesCsvPropertiesUploadCsvPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get property by ID
 * @summary Get Property
 */
export const getPropertyPropertiesPropertyIdGet = (
  propertyId: string,
  signal?: AbortSignal,
) => {
  return api<PropertyResponse>({
    url: `https://api.atuna.org/properties/${propertyId}`,
    method: "GET",
    signal,
  });
};

export const getGetPropertyPropertiesPropertyIdGetQueryKey = (
  propertyId?: string,
) => {
  return [`https://api.atuna.org/properties/${propertyId}`] as const;
};

export const getGetPropertyPropertiesPropertyIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPropertyPropertiesPropertyIdGetQueryKey(propertyId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>
  > = ({ signal }) => getPropertyPropertiesPropertyIdGet(propertyId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!propertyId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPropertyPropertiesPropertyIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>
>;
export type GetPropertyPropertiesPropertyIdGetQueryError = HTTPValidationError;

export function useGetPropertyPropertiesPropertyIdGet<
  TData = Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPropertyPropertiesPropertyIdGet<
  TData = Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPropertyPropertiesPropertyIdGet<
  TData = Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Property
 */

export function useGetPropertyPropertiesPropertyIdGet<
  TData = Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyPropertiesPropertyIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPropertyPropertiesPropertyIdGetQueryOptions(
    propertyId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update property information
 * @summary Update Property
 */
export const updatePropertyPropertiesPropertyIdPut = (
  propertyId: string,
  propertyUpdate: PropertyUpdate,
) => {
  return api<PropertyResponse>({
    url: `https://api.atuna.org/properties/${propertyId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: propertyUpdate,
  });
};

export const getUpdatePropertyPropertiesPropertyIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePropertyPropertiesPropertyIdPut>>,
    TError,
    { propertyId: string; data: PropertyUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePropertyPropertiesPropertyIdPut>>,
  TError,
  { propertyId: string; data: PropertyUpdate },
  TContext
> => {
  const mutationKey = ["updatePropertyPropertiesPropertyIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePropertyPropertiesPropertyIdPut>>,
    { propertyId: string; data: PropertyUpdate }
  > = (props) => {
    const { propertyId, data } = props ?? {};

    return updatePropertyPropertiesPropertyIdPut(propertyId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePropertyPropertiesPropertyIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePropertyPropertiesPropertyIdPut>>
>;
export type UpdatePropertyPropertiesPropertyIdPutMutationBody = PropertyUpdate;
export type UpdatePropertyPropertiesPropertyIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Property
 */
export const useUpdatePropertyPropertiesPropertyIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePropertyPropertiesPropertyIdPut>>,
      TError,
      { propertyId: string; data: PropertyUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePropertyPropertiesPropertyIdPut>>,
  TError,
  { propertyId: string; data: PropertyUpdate },
  TContext
> => {
  const mutationOptions =
    getUpdatePropertyPropertiesPropertyIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Archive property (soft delete)
 * @summary Archive Property
 */
export const archivePropertyPropertiesPropertyIdDelete = (
  propertyId: string,
) => {
  return api<PropertyResponse>({
    url: `https://api.atuna.org/properties/${propertyId}`,
    method: "DELETE",
  });
};

export const getArchivePropertyPropertiesPropertyIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archivePropertyPropertiesPropertyIdDelete>>,
    TError,
    { propertyId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof archivePropertyPropertiesPropertyIdDelete>>,
  TError,
  { propertyId: string },
  TContext
> => {
  const mutationKey = ["archivePropertyPropertiesPropertyIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof archivePropertyPropertiesPropertyIdDelete>>,
    { propertyId: string }
  > = (props) => {
    const { propertyId } = props ?? {};

    return archivePropertyPropertiesPropertyIdDelete(propertyId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ArchivePropertyPropertiesPropertyIdDeleteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof archivePropertyPropertiesPropertyIdDelete>>
  >;

export type ArchivePropertyPropertiesPropertyIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Archive Property
 */
export const useArchivePropertyPropertiesPropertyIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archivePropertyPropertiesPropertyIdDelete>>,
      TError,
      { propertyId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof archivePropertyPropertiesPropertyIdDelete>>,
  TError,
  { propertyId: string },
  TContext
> => {
  const mutationOptions =
    getArchivePropertyPropertiesPropertyIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Assign property to broker or agent
 * @summary Assign Property
 */
export const assignPropertyPropertiesPropertyIdAssignPost = (
  propertyId: string,
  propertyAssignmentCreate: PropertyAssignmentCreate,
  signal?: AbortSignal,
) => {
  return api<PropertyAssignmentResponse>({
    url: `https://api.atuna.org/properties/${propertyId}/assign`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: propertyAssignmentCreate,
    signal,
  });
};

export const getAssignPropertyPropertiesPropertyIdAssignPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assignPropertyPropertiesPropertyIdAssignPost>>,
    TError,
    { propertyId: string; data: PropertyAssignmentCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assignPropertyPropertiesPropertyIdAssignPost>>,
  TError,
  { propertyId: string; data: PropertyAssignmentCreate },
  TContext
> => {
  const mutationKey = ["assignPropertyPropertiesPropertyIdAssignPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assignPropertyPropertiesPropertyIdAssignPost>>,
    { propertyId: string; data: PropertyAssignmentCreate }
  > = (props) => {
    const { propertyId, data } = props ?? {};

    return assignPropertyPropertiesPropertyIdAssignPost(propertyId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssignPropertyPropertiesPropertyIdAssignPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof assignPropertyPropertiesPropertyIdAssignPost>>
  >;
export type AssignPropertyPropertiesPropertyIdAssignPostMutationBody =
  PropertyAssignmentCreate;
export type AssignPropertyPropertiesPropertyIdAssignPostMutationError =
  HTTPValidationError;

/**
 * @summary Assign Property
 */
export const useAssignPropertyPropertiesPropertyIdAssignPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assignPropertyPropertiesPropertyIdAssignPost>>,
      TError,
      { propertyId: string; data: PropertyAssignmentCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assignPropertyPropertiesPropertyIdAssignPost>>,
  TError,
  { propertyId: string; data: PropertyAssignmentCreate },
  TContext
> => {
  const mutationOptions =
    getAssignPropertyPropertiesPropertyIdAssignPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get CSV template for bulk property upload
 * @summary Get Csv Template
 */
export const getCsvTemplatePropertiesCsvTemplateGet = (
  signal?: AbortSignal,
) => {
  return api<unknown>({
    url: `https://api.atuna.org/properties/csv-template`,
    method: "GET",
    signal,
  });
};

export const getGetCsvTemplatePropertiesCsvTemplateGetQueryKey = () => {
  return [`https://api.atuna.org/properties/csv-template`] as const;
};

export const getGetCsvTemplatePropertiesCsvTemplateGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetCsvTemplatePropertiesCsvTemplateGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>
  > = ({ signal }) => getCsvTemplatePropertiesCsvTemplateGet(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCsvTemplatePropertiesCsvTemplateGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>
>;
export type GetCsvTemplatePropertiesCsvTemplateGetQueryError = unknown;

export function useGetCsvTemplatePropertiesCsvTemplateGet<
  TData = Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
          TError,
          Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCsvTemplatePropertiesCsvTemplateGet<
  TData = Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
          TError,
          Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCsvTemplatePropertiesCsvTemplateGet<
  TData = Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Csv Template
 */

export function useGetCsvTemplatePropertiesCsvTemplateGet<
  TData = Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCsvTemplatePropertiesCsvTemplateGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetCsvTemplatePropertiesCsvTemplateGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Schedule a site viewing (guests can schedule without account)
 * @summary Schedule Site Viewing
 */
export const scheduleSiteViewingSiteViewingsPost = (
  siteViewingCreate: SiteViewingCreate,
  signal?: AbortSignal,
) => {
  return api<SiteViewingResponse>({
    url: `https://api.atuna.org/site-viewings/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: siteViewingCreate,
    signal,
  });
};

export const getScheduleSiteViewingSiteViewingsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof scheduleSiteViewingSiteViewingsPost>>,
    TError,
    { data: SiteViewingCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof scheduleSiteViewingSiteViewingsPost>>,
  TError,
  { data: SiteViewingCreate },
  TContext
> => {
  const mutationKey = ["scheduleSiteViewingSiteViewingsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scheduleSiteViewingSiteViewingsPost>>,
    { data: SiteViewingCreate }
  > = (props) => {
    const { data } = props ?? {};

    return scheduleSiteViewingSiteViewingsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScheduleSiteViewingSiteViewingsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof scheduleSiteViewingSiteViewingsPost>>
>;
export type ScheduleSiteViewingSiteViewingsPostMutationBody = SiteViewingCreate;
export type ScheduleSiteViewingSiteViewingsPostMutationError =
  HTTPValidationError;

/**
 * @summary Schedule Site Viewing
 */
export const useScheduleSiteViewingSiteViewingsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof scheduleSiteViewingSiteViewingsPost>>,
      TError,
      { data: SiteViewingCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof scheduleSiteViewingSiteViewingsPost>>,
  TError,
  { data: SiteViewingCreate },
  TContext
> => {
  const mutationOptions =
    getScheduleSiteViewingSiteViewingsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get user's site viewings
 * @summary Get Site Viewings
 */
export const getSiteViewingsSiteViewingsGet = (
  params?: GetSiteViewingsSiteViewingsGetParams,
  signal?: AbortSignal,
) => {
  return api<SiteViewingResponse[]>({
    url: `https://api.atuna.org/site-viewings/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSiteViewingsSiteViewingsGetQueryKey = (
  params?: GetSiteViewingsSiteViewingsGetParams,
) => {
  return [
    `https://api.atuna.org/site-viewings/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSiteViewingsSiteViewingsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSiteViewingsSiteViewingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSiteViewingsSiteViewingsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>
  > = ({ signal }) => getSiteViewingsSiteViewingsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSiteViewingsSiteViewingsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>
>;
export type GetSiteViewingsSiteViewingsGetQueryError = HTTPValidationError;

export function useGetSiteViewingsSiteViewingsGet<
  TData = Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetSiteViewingsSiteViewingsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
          TError,
          Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSiteViewingsSiteViewingsGet<
  TData = Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSiteViewingsSiteViewingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
          TError,
          Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSiteViewingsSiteViewingsGet<
  TData = Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSiteViewingsSiteViewingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Site Viewings
 */

export function useGetSiteViewingsSiteViewingsGet<
  TData = Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSiteViewingsSiteViewingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSiteViewingsSiteViewingsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSiteViewingsSiteViewingsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update site viewing details
 * @summary Update Site Viewing
 */
export const updateSiteViewingSiteViewingsViewingIdPut = (
  viewingId: string,
  siteViewingUpdate: SiteViewingUpdate,
) => {
  return api<SiteViewingResponse>({
    url: `https://api.atuna.org/site-viewings/${viewingId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: siteViewingUpdate,
  });
};

export const getUpdateSiteViewingSiteViewingsViewingIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSiteViewingSiteViewingsViewingIdPut>>,
    TError,
    { viewingId: string; data: SiteViewingUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSiteViewingSiteViewingsViewingIdPut>>,
  TError,
  { viewingId: string; data: SiteViewingUpdate },
  TContext
> => {
  const mutationKey = ["updateSiteViewingSiteViewingsViewingIdPut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSiteViewingSiteViewingsViewingIdPut>>,
    { viewingId: string; data: SiteViewingUpdate }
  > = (props) => {
    const { viewingId, data } = props ?? {};

    return updateSiteViewingSiteViewingsViewingIdPut(viewingId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSiteViewingSiteViewingsViewingIdPutMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateSiteViewingSiteViewingsViewingIdPut>>
  >;
export type UpdateSiteViewingSiteViewingsViewingIdPutMutationBody =
  SiteViewingUpdate;
export type UpdateSiteViewingSiteViewingsViewingIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Site Viewing
 */
export const useUpdateSiteViewingSiteViewingsViewingIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSiteViewingSiteViewingsViewingIdPut>>,
      TError,
      { viewingId: string; data: SiteViewingUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateSiteViewingSiteViewingsViewingIdPut>>,
  TError,
  { viewingId: string; data: SiteViewingUpdate },
  TContext
> => {
  const mutationOptions =
    getUpdateSiteViewingSiteViewingsViewingIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Cancel site viewing
 * @summary Cancel Site Viewing
 */
export const cancelSiteViewingSiteViewingsViewingIdDelete = (
  viewingId: string,
) => {
  return api<CancelSiteViewingSiteViewingsViewingIdDelete200>({
    url: `https://api.atuna.org/site-viewings/${viewingId}`,
    method: "DELETE",
  });
};

export const getCancelSiteViewingSiteViewingsViewingIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelSiteViewingSiteViewingsViewingIdDelete>>,
    TError,
    { viewingId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelSiteViewingSiteViewingsViewingIdDelete>>,
  TError,
  { viewingId: string },
  TContext
> => {
  const mutationKey = ["cancelSiteViewingSiteViewingsViewingIdDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelSiteViewingSiteViewingsViewingIdDelete>>,
    { viewingId: string }
  > = (props) => {
    const { viewingId } = props ?? {};

    return cancelSiteViewingSiteViewingsViewingIdDelete(viewingId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelSiteViewingSiteViewingsViewingIdDeleteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof cancelSiteViewingSiteViewingsViewingIdDelete>>
  >;

export type CancelSiteViewingSiteViewingsViewingIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Cancel Site Viewing
 */
export const useCancelSiteViewingSiteViewingsViewingIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelSiteViewingSiteViewingsViewingIdDelete>>,
      TError,
      { viewingId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof cancelSiteViewingSiteViewingsViewingIdDelete>>,
  TError,
  { viewingId: string },
  TContext
> => {
  const mutationOptions =
    getCancelSiteViewingSiteViewingsViewingIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new lead in CRM pipeline
 * @summary Create Lead
 */
export const createLeadSiteViewingsCrmLeadsPost = (
  leadCreate: LeadCreate,
  signal?: AbortSignal,
) => {
  return api<LeadResponse>({
    url: `https://api.atuna.org/site-viewings/crm/leads`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: leadCreate,
    signal,
  });
};

export const getCreateLeadSiteViewingsCrmLeadsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createLeadSiteViewingsCrmLeadsPost>>,
    TError,
    { data: LeadCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createLeadSiteViewingsCrmLeadsPost>>,
  TError,
  { data: LeadCreate },
  TContext
> => {
  const mutationKey = ["createLeadSiteViewingsCrmLeadsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLeadSiteViewingsCrmLeadsPost>>,
    { data: LeadCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createLeadSiteViewingsCrmLeadsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateLeadSiteViewingsCrmLeadsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createLeadSiteViewingsCrmLeadsPost>>
>;
export type CreateLeadSiteViewingsCrmLeadsPostMutationBody = LeadCreate;
export type CreateLeadSiteViewingsCrmLeadsPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Lead
 */
export const useCreateLeadSiteViewingsCrmLeadsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createLeadSiteViewingsCrmLeadsPost>>,
      TError,
      { data: LeadCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createLeadSiteViewingsCrmLeadsPost>>,
  TError,
  { data: LeadCreate },
  TContext
> => {
  const mutationOptions =
    getCreateLeadSiteViewingsCrmLeadsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get leads in CRM pipeline
 * @summary Get Leads
 */
export const getLeadsSiteViewingsCrmLeadsGet = (
  params?: GetLeadsSiteViewingsCrmLeadsGetParams,
  signal?: AbortSignal,
) => {
  return api<LeadResponse[]>({
    url: `https://api.atuna.org/site-viewings/crm/leads`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLeadsSiteViewingsCrmLeadsGetQueryKey = (
  params?: GetLeadsSiteViewingsCrmLeadsGetParams,
) => {
  return [
    `https://api.atuna.org/site-viewings/crm/leads`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLeadsSiteViewingsCrmLeadsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsSiteViewingsCrmLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetLeadsSiteViewingsCrmLeadsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>
  > = ({ signal }) => getLeadsSiteViewingsCrmLeadsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLeadsSiteViewingsCrmLeadsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>
>;
export type GetLeadsSiteViewingsCrmLeadsGetQueryError = HTTPValidationError;

export function useGetLeadsSiteViewingsCrmLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetLeadsSiteViewingsCrmLeadsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
          TError,
          Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeadsSiteViewingsCrmLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsSiteViewingsCrmLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
          TError,
          Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeadsSiteViewingsCrmLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsSiteViewingsCrmLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Leads
 */

export function useGetLeadsSiteViewingsCrmLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsSiteViewingsCrmLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsSiteViewingsCrmLeadsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetLeadsSiteViewingsCrmLeadsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update lead status in CRM pipeline
 * @summary Update Lead Status
 */
export const updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut = (
  leadId: string,
  params: UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutParams,
) => {
  return api<LeadResponse>({
    url: `https://api.atuna.org/site-viewings/crm/leads/${leadId}/status`,
    method: "PUT",
    params,
  });
};

export const getUpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut>
      >,
      TError,
      {
        leadId: string;
        params: UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutParams;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut>
    >,
    TError,
    {
      leadId: string;
      params: UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutParams;
    },
    TContext
  > => {
    const mutationKey = ["updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut>
      >,
      {
        leadId: string;
        params: UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutParams;
      }
    > = (props) => {
      const { leadId, params } = props ?? {};

      return updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut(
        leadId,
        params,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut>
    >
  >;

export type UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Lead Status
 */
export const useUpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut>
      >,
      TError,
      {
        leadId: string;
        params: UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof updateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPut>
  >,
  TError,
  {
    leadId: string;
    params: UpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutParams;
  },
  TContext
> => {
  const mutationOptions =
    getUpdateLeadStatusSiteViewingsCrmLeadsLeadIdStatusPutMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get detailed lead information
 * @summary Get Lead Details
 */
export const getLeadDetailsSiteViewingsCrmLeadsLeadIdGet = (
  leadId: string,
  signal?: AbortSignal,
) => {
  return api<LeadResponse>({
    url: `https://api.atuna.org/site-viewings/crm/leads/${leadId}`,
    method: "GET",
    signal,
  });
};

export const getGetLeadDetailsSiteViewingsCrmLeadsLeadIdGetQueryKey = (
  leadId?: string,
) => {
  return [`https://api.atuna.org/site-viewings/crm/leads/${leadId}`] as const;
};

export const getGetLeadDetailsSiteViewingsCrmLeadsLeadIdGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
  >,
  TError = HTTPValidationError,
>(
  leadId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetLeadDetailsSiteViewingsCrmLeadsLeadIdGetQueryKey(leadId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>>
  > = ({ signal }) =>
    getLeadDetailsSiteViewingsCrmLeadsLeadIdGet(leadId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!leadId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLeadDetailsSiteViewingsCrmLeadsLeadIdGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>>
  >;
export type GetLeadDetailsSiteViewingsCrmLeadsLeadIdGetQueryError =
  HTTPValidationError;

export function useGetLeadDetailsSiteViewingsCrmLeadsLeadIdGet<
  TData = Awaited<
    ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
  >,
  TError = HTTPValidationError,
>(
  leadId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeadDetailsSiteViewingsCrmLeadsLeadIdGet<
  TData = Awaited<
    ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
  >,
  TError = HTTPValidationError,
>(
  leadId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeadDetailsSiteViewingsCrmLeadsLeadIdGet<
  TData = Awaited<
    ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
  >,
  TError = HTTPValidationError,
>(
  leadId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Lead Details
 */

export function useGetLeadDetailsSiteViewingsCrmLeadsLeadIdGet<
  TData = Awaited<
    ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>
  >,
  TError = HTTPValidationError,
>(
  leadId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadDetailsSiteViewingsCrmLeadsLeadIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetLeadDetailsSiteViewingsCrmLeadsLeadIdGetQueryOptions(leadId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get CRM pipeline summary with counts by status
 * @summary Get Pipeline Summary
 */
export const getPipelineSummarySiteViewingsCrmPipelineSummaryGet = (
  params?: GetPipelineSummarySiteViewingsCrmPipelineSummaryGetParams,
  signal?: AbortSignal,
) => {
  return api<GetPipelineSummarySiteViewingsCrmPipelineSummaryGet200>({
    url: `https://api.atuna.org/site-viewings/crm/pipeline-summary`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPipelineSummarySiteViewingsCrmPipelineSummaryGetQueryKey = (
  params?: GetPipelineSummarySiteViewingsCrmPipelineSummaryGetParams,
) => {
  return [
    `https://api.atuna.org/site-viewings/crm/pipeline-summary`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetPipelineSummarySiteViewingsCrmPipelineSummaryGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
    >,
    TError = HTTPValidationError,
  >(
    params?: GetPipelineSummarySiteViewingsCrmPipelineSummaryGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetPipelineSummarySiteViewingsCrmPipelineSummaryGetQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
      >
    > = ({ signal }) =>
      getPipelineSummarySiteViewingsCrmPipelineSummaryGet(params, signal);

    return {
      queryKey,
      queryFn,
      staleTime: 30000,
      refetchOnWindowFocus: false,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetPipelineSummarySiteViewingsCrmPipelineSummaryGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
    >
  >;
export type GetPipelineSummarySiteViewingsCrmPipelineSummaryGetQueryError =
  HTTPValidationError;

export function useGetPipelineSummarySiteViewingsCrmPipelineSummaryGet<
  TData = Awaited<
    ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
  >,
  TError = HTTPValidationError,
>(
  params: undefined | GetPipelineSummarySiteViewingsCrmPipelineSummaryGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPipelineSummarySiteViewingsCrmPipelineSummaryGet<
  TData = Awaited<
    ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetPipelineSummarySiteViewingsCrmPipelineSummaryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPipelineSummarySiteViewingsCrmPipelineSummaryGet<
  TData = Awaited<
    ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetPipelineSummarySiteViewingsCrmPipelineSummaryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Pipeline Summary
 */

export function useGetPipelineSummarySiteViewingsCrmPipelineSummaryGet<
  TData = Awaited<
    ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
  >,
  TError = HTTPValidationError,
>(
  params?: GetPipelineSummarySiteViewingsCrmPipelineSummaryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getPipelineSummarySiteViewingsCrmPipelineSummaryGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetPipelineSummarySiteViewingsCrmPipelineSummaryGetQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a maintenance request
 * @summary Create Maintenance Request
 */
export const createMaintenanceRequestMaintenancePost = (
  maintenanceRequestCreate: MaintenanceRequestCreate,
  signal?: AbortSignal,
) => {
  return api<CreateMaintenanceRequestMaintenancePost200>({
    url: `https://api.atuna.org/maintenance/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: maintenanceRequestCreate,
    signal,
  });
};

export const getCreateMaintenanceRequestMaintenancePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMaintenanceRequestMaintenancePost>>,
    TError,
    { data: MaintenanceRequestCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMaintenanceRequestMaintenancePost>>,
  TError,
  { data: MaintenanceRequestCreate },
  TContext
> => {
  const mutationKey = ["createMaintenanceRequestMaintenancePost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMaintenanceRequestMaintenancePost>>,
    { data: MaintenanceRequestCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createMaintenanceRequestMaintenancePost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMaintenanceRequestMaintenancePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMaintenanceRequestMaintenancePost>>
>;
export type CreateMaintenanceRequestMaintenancePostMutationBody =
  MaintenanceRequestCreate;
export type CreateMaintenanceRequestMaintenancePostMutationError =
  HTTPValidationError;

/**
 * @summary Create Maintenance Request
 */
export const useCreateMaintenanceRequestMaintenancePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMaintenanceRequestMaintenancePost>>,
      TError,
      { data: MaintenanceRequestCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createMaintenanceRequestMaintenancePost>>,
  TError,
  { data: MaintenanceRequestCreate },
  TContext
> => {
  const mutationOptions =
    getCreateMaintenanceRequestMaintenancePostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get maintenance requests (clients see their own, developers see their properties)
 * @summary Get Maintenance Requests
 */
export const getMaintenanceRequestsMaintenanceGet = (
  params?: GetMaintenanceRequestsMaintenanceGetParams,
  signal?: AbortSignal,
) => {
  return api<GetMaintenanceRequestsMaintenanceGet200Item[]>({
    url: `https://api.atuna.org/maintenance/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetMaintenanceRequestsMaintenanceGetQueryKey = (
  params?: GetMaintenanceRequestsMaintenanceGetParams,
) => {
  return [
    `https://api.atuna.org/maintenance/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMaintenanceRequestsMaintenanceGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
  TError = HTTPValidationError,
>(
  params?: GetMaintenanceRequestsMaintenanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetMaintenanceRequestsMaintenanceGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>
  > = ({ signal }) => getMaintenanceRequestsMaintenanceGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMaintenanceRequestsMaintenanceGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>
>;
export type GetMaintenanceRequestsMaintenanceGetQueryError =
  HTTPValidationError;

export function useGetMaintenanceRequestsMaintenanceGet<
  TData = Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetMaintenanceRequestsMaintenanceGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
          TError,
          Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMaintenanceRequestsMaintenanceGet<
  TData = Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
  TError = HTTPValidationError,
>(
  params?: GetMaintenanceRequestsMaintenanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
          TError,
          Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMaintenanceRequestsMaintenanceGet<
  TData = Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
  TError = HTTPValidationError,
>(
  params?: GetMaintenanceRequestsMaintenanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Maintenance Requests
 */

export function useGetMaintenanceRequestsMaintenanceGet<
  TData = Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
  TError = HTTPValidationError,
>(
  params?: GetMaintenanceRequestsMaintenanceGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMaintenanceRequestsMaintenanceGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMaintenanceRequestsMaintenanceGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update maintenance request (developers can update status, clients can update details)
 * @summary Update Maintenance Request
 */
export const updateMaintenanceRequestMaintenanceRequestIdPut = (
  requestId: string,
  maintenanceRequestUpdate: MaintenanceRequestUpdate,
) => {
  return api<UpdateMaintenanceRequestMaintenanceRequestIdPut200>({
    url: `https://api.atuna.org/maintenance/${requestId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: maintenanceRequestUpdate,
  });
};

export const getUpdateMaintenanceRequestMaintenanceRequestIdPutMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateMaintenanceRequestMaintenanceRequestIdPut>
      >,
      TError,
      { requestId: string; data: MaintenanceRequestUpdate },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof updateMaintenanceRequestMaintenanceRequestIdPut>>,
    TError,
    { requestId: string; data: MaintenanceRequestUpdate },
    TContext
  > => {
    const mutationKey = ["updateMaintenanceRequestMaintenanceRequestIdPut"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateMaintenanceRequestMaintenanceRequestIdPut>
      >,
      { requestId: string; data: MaintenanceRequestUpdate }
    > = (props) => {
      const { requestId, data } = props ?? {};

      return updateMaintenanceRequestMaintenanceRequestIdPut(requestId, data);
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateMaintenanceRequestMaintenanceRequestIdPutMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateMaintenanceRequestMaintenanceRequestIdPut>>
  >;
export type UpdateMaintenanceRequestMaintenanceRequestIdPutMutationBody =
  MaintenanceRequestUpdate;
export type UpdateMaintenanceRequestMaintenanceRequestIdPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Maintenance Request
 */
export const useUpdateMaintenanceRequestMaintenanceRequestIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateMaintenanceRequestMaintenanceRequestIdPut>
      >,
      TError,
      { requestId: string; data: MaintenanceRequestUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateMaintenanceRequestMaintenanceRequestIdPut>>,
  TError,
  { requestId: string; data: MaintenanceRequestUpdate },
  TContext
> => {
  const mutationOptions =
    getUpdateMaintenanceRequestMaintenanceRequestIdPutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get detailed maintenance request
 * @summary Get Maintenance Request
 */
export const getMaintenanceRequestMaintenanceRequestIdGet = (
  requestId: string,
  signal?: AbortSignal,
) => {
  return api<GetMaintenanceRequestMaintenanceRequestIdGet200>({
    url: `https://api.atuna.org/maintenance/${requestId}`,
    method: "GET",
    signal,
  });
};

export const getGetMaintenanceRequestMaintenanceRequestIdGetQueryKey = (
  requestId?: string,
) => {
  return [`https://api.atuna.org/maintenance/${requestId}`] as const;
};

export const getGetMaintenanceRequestMaintenanceRequestIdGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
  >,
  TError = HTTPValidationError,
>(
  requestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetMaintenanceRequestMaintenanceRequestIdGetQueryKey(requestId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>>
  > = ({ signal }) =>
    getMaintenanceRequestMaintenanceRequestIdGet(requestId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!requestId,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMaintenanceRequestMaintenanceRequestIdGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>>
  >;
export type GetMaintenanceRequestMaintenanceRequestIdGetQueryError =
  HTTPValidationError;

export function useGetMaintenanceRequestMaintenanceRequestIdGet<
  TData = Awaited<
    ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
  >,
  TError = HTTPValidationError,
>(
  requestId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMaintenanceRequestMaintenanceRequestIdGet<
  TData = Awaited<
    ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
  >,
  TError = HTTPValidationError,
>(
  requestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMaintenanceRequestMaintenanceRequestIdGet<
  TData = Awaited<
    ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
  >,
  TError = HTTPValidationError,
>(
  requestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Maintenance Request
 */

export function useGetMaintenanceRequestMaintenanceRequestIdGet<
  TData = Awaited<
    ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
  >,
  TError = HTTPValidationError,
>(
  requestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getMaintenanceRequestMaintenanceRequestIdGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetMaintenanceRequestMaintenanceRequestIdGetQueryOptions(
      requestId,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a payment (downpayment, installment, etc.)
 * @summary Create Payment
 */
export const createPaymentMaintenancePaymentsPost = (
  paymentCreate: PaymentCreate,
  signal?: AbortSignal,
) => {
  return api<CreatePaymentMaintenancePaymentsPost200>({
    url: `https://api.atuna.org/maintenance/payments/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: paymentCreate,
    signal,
  });
};

export const getCreatePaymentMaintenancePaymentsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPaymentMaintenancePaymentsPost>>,
    TError,
    { data: PaymentCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPaymentMaintenancePaymentsPost>>,
  TError,
  { data: PaymentCreate },
  TContext
> => {
  const mutationKey = ["createPaymentMaintenancePaymentsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPaymentMaintenancePaymentsPost>>,
    { data: PaymentCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createPaymentMaintenancePaymentsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePaymentMaintenancePaymentsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPaymentMaintenancePaymentsPost>>
>;
export type CreatePaymentMaintenancePaymentsPostMutationBody = PaymentCreate;
export type CreatePaymentMaintenancePaymentsPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Payment
 */
export const useCreatePaymentMaintenancePaymentsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPaymentMaintenancePaymentsPost>>,
      TError,
      { data: PaymentCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createPaymentMaintenancePaymentsPost>>,
  TError,
  { data: PaymentCreate },
  TContext
> => {
  const mutationOptions =
    getCreatePaymentMaintenancePaymentsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get payment history
 * @summary Get Payments
 */
export const getPaymentsMaintenancePaymentsGet = (
  params?: GetPaymentsMaintenancePaymentsGetParams,
  signal?: AbortSignal,
) => {
  return api<GetPaymentsMaintenancePaymentsGet200Item[]>({
    url: `https://api.atuna.org/maintenance/payments/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPaymentsMaintenancePaymentsGetQueryKey = (
  params?: GetPaymentsMaintenancePaymentsGetParams,
) => {
  return [
    `https://api.atuna.org/maintenance/payments/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetPaymentsMaintenancePaymentsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPaymentsMaintenancePaymentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPaymentsMaintenancePaymentsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>
  > = ({ signal }) => getPaymentsMaintenancePaymentsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPaymentsMaintenancePaymentsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>
>;
export type GetPaymentsMaintenancePaymentsGetQueryError = HTTPValidationError;

export function useGetPaymentsMaintenancePaymentsGet<
  TData = Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetPaymentsMaintenancePaymentsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
          TError,
          Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPaymentsMaintenancePaymentsGet<
  TData = Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPaymentsMaintenancePaymentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
          TError,
          Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPaymentsMaintenancePaymentsGet<
  TData = Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPaymentsMaintenancePaymentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Payments
 */

export function useGetPaymentsMaintenancePaymentsGet<
  TData = Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPaymentsMaintenancePaymentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentsMaintenancePaymentsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPaymentsMaintenancePaymentsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update payment status (for developers/admins to confirm payments)
 * @summary Update Payment Status
 */
export const updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut = (
  paymentId: string,
  params: UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutParams,
) => {
  return api<UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPut200>({
    url: `https://api.atuna.org/maintenance/payments/${paymentId}/status`,
    method: "PUT",
    params,
  });
};

export const getUpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut
        >
      >,
      TError,
      {
        paymentId: string;
        params: UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutParams;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut
      >
    >,
    TError,
    {
      paymentId: string;
      params: UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutParams;
    },
    TContext
  > => {
    const mutationKey = [
      "updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut",
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut
        >
      >,
      {
        paymentId: string;
        params: UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutParams;
      }
    > = (props) => {
      const { paymentId, params } = props ?? {};

      return updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut(
        paymentId,
        params,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut
      >
    >
  >;

export type UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Payment Status
 */
export const useUpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut
        >
      >,
      TError,
      {
        paymentId: string;
        params: UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof updatePaymentStatusMaintenancePaymentsPaymentIdStatusPut>
  >,
  TError,
  {
    paymentId: string;
    params: UpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutParams;
  },
  TContext
> => {
  const mutationOptions =
    getUpdatePaymentStatusMaintenancePaymentsPaymentIdStatusPutMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get payment receipt/proof
 * @summary Get Payment Receipt
 */
export const getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet = (
  paymentId: string,
  signal?: AbortSignal,
) => {
  return api<GetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet200>({
    url: `https://api.atuna.org/maintenance/payments/${paymentId}/receipt`,
    method: "GET",
    signal,
  });
};

export const getGetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGetQueryKey =
  (paymentId?: string) => {
    return [
      `https://api.atuna.org/maintenance/payments/${paymentId}/receipt`,
    ] as const;
  };

export const getGetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet>
    >,
    TError = HTTPValidationError,
  >(
    paymentId: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGetQueryKey(
        paymentId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
        >
      >
    > = ({ signal }) =>
      getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet(
        paymentId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!paymentId,
      staleTime: 30000,
      refetchOnWindowFocus: false,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet>
    >
  >;
export type GetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGetQueryError =
  HTTPValidationError;

export function useGetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet<
  TData = Awaited<
    ReturnType<typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet>
  >,
  TError = HTTPValidationError,
>(
  paymentId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet<
  TData = Awaited<
    ReturnType<typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet>
  >,
  TError = HTTPValidationError,
>(
  paymentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet<
  TData = Awaited<
    ReturnType<typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet>
  >,
  TError = HTTPValidationError,
>(
  paymentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Payment Receipt
 */

export function useGetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet<
  TData = Awaited<
    ReturnType<typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet>
  >,
  TError = HTTPValidationError,
>(
  paymentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPaymentReceiptMaintenancePaymentsPaymentIdReceiptGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetPaymentReceiptMaintenancePaymentsPaymentIdReceiptGetQueryOptions(
      paymentId,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get payment schedule for a property
 * @summary Get Payment Schedule
 */
export const getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet =
  (propertyId: string, signal?: AbortSignal) => {
    return api<GetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet200>(
      {
        url: `https://api.atuna.org/maintenance/payments/property/${propertyId}/schedule`,
        method: "GET",
        signal,
      },
    );
  };

export const getGetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGetQueryKey =
  (propertyId?: string) => {
    return [
      `https://api.atuna.org/maintenance/payments/property/${propertyId}/schedule`,
    ] as const;
  };

export const getGetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
      >
    >,
    TError = HTTPValidationError,
  >(
    propertyId: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGetQueryKey(
        propertyId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
        >
      >
    > = ({ signal }) =>
      getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet(
        propertyId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!propertyId,
      staleTime: 30000,
      refetchOnWindowFocus: false,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
      >
    >
  >;
export type GetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGetQueryError =
  HTTPValidationError;

export function useGetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet<
  TData = Awaited<
    ReturnType<
      typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
    >
  >,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet<
  TData = Awaited<
    ReturnType<
      typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
    >
  >,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet<
  TData = Awaited<
    ReturnType<
      typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
    >
  >,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Payment Schedule
 */

export function useGetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet<
  TData = Awaited<
    ReturnType<
      typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
    >
  >,
  TError = HTTPValidationError,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetPaymentScheduleMaintenancePaymentsPropertyPropertyIdScheduleGetQueryOptions(
      propertyId,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Add agent to team
 * @summary Add Agent To Team
 */
export const addAgentToTeamTeamsTeamIdAgentsPost = (
  teamId: string,
  params: AddAgentToTeamTeamsTeamIdAgentsPostParams,
  signal?: AbortSignal,
) => {
  return api<AddAgentToTeamTeamsTeamIdAgentsPost200>({
    url: `https://api.atuna.org/teams/${teamId}/agents`,
    method: "POST",
    params,
    signal,
  });
};

export const getAddAgentToTeamTeamsTeamIdAgentsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addAgentToTeamTeamsTeamIdAgentsPost>>,
    TError,
    { teamId: string; params: AddAgentToTeamTeamsTeamIdAgentsPostParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addAgentToTeamTeamsTeamIdAgentsPost>>,
  TError,
  { teamId: string; params: AddAgentToTeamTeamsTeamIdAgentsPostParams },
  TContext
> => {
  const mutationKey = ["addAgentToTeamTeamsTeamIdAgentsPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addAgentToTeamTeamsTeamIdAgentsPost>>,
    { teamId: string; params: AddAgentToTeamTeamsTeamIdAgentsPostParams }
  > = (props) => {
    const { teamId, params } = props ?? {};

    return addAgentToTeamTeamsTeamIdAgentsPost(teamId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddAgentToTeamTeamsTeamIdAgentsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addAgentToTeamTeamsTeamIdAgentsPost>>
>;

export type AddAgentToTeamTeamsTeamIdAgentsPostMutationError =
  HTTPValidationError;

/**
 * @summary Add Agent To Team
 */
export const useAddAgentToTeamTeamsTeamIdAgentsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addAgentToTeamTeamsTeamIdAgentsPost>>,
      TError,
      { teamId: string; params: AddAgentToTeamTeamsTeamIdAgentsPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addAgentToTeamTeamsTeamIdAgentsPost>>,
  TError,
  { teamId: string; params: AddAgentToTeamTeamsTeamIdAgentsPostParams },
  TContext
> => {
  const mutationOptions =
    getAddAgentToTeamTeamsTeamIdAgentsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Remove agent from team
 * @summary Remove Agent From Team
 */
export const removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete = (
  teamId: string,
  agentId: string,
) => {
  return api<RemoveAgentFromTeamTeamsTeamIdAgentsAgentIdDelete200>({
    url: `https://api.atuna.org/teams/${teamId}/agents/${agentId}`,
    method: "DELETE",
  });
};

export const getRemoveAgentFromTeamTeamsTeamIdAgentsAgentIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete>
      >,
      TError,
      { teamId: string; agentId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete>
    >,
    TError,
    { teamId: string; agentId: string },
    TContext
  > => {
    const mutationKey = ["removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete>
      >,
      { teamId: string; agentId: string }
    > = (props) => {
      const { teamId, agentId } = props ?? {};

      return removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete(teamId, agentId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type RemoveAgentFromTeamTeamsTeamIdAgentsAgentIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete>
    >
  >;

export type RemoveAgentFromTeamTeamsTeamIdAgentsAgentIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Remove Agent From Team
 */
export const useRemoveAgentFromTeamTeamsTeamIdAgentsAgentIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete>
      >,
      TError,
      { teamId: string; agentId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeAgentFromTeamTeamsTeamIdAgentsAgentIdDelete>>,
  TError,
  { teamId: string; agentId: string },
  TContext
> => {
  const mutationOptions =
    getRemoveAgentFromTeamTeamsTeamIdAgentsAgentIdDeleteMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Activate/deactivate agent in team
 * @summary Update Agent Status
 */
export const updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut = (
  teamId: string,
  agentId: string,
  params: UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutParams,
) => {
  return api<UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut200>({
    url: `https://api.atuna.org/teams/${teamId}/agents/${agentId}/status`,
    method: "PUT",
    params,
  });
};

export const getUpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut>
      >,
      TError,
      {
        teamId: string;
        agentId: string;
        params: UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutParams;
      },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut>
    >,
    TError,
    {
      teamId: string;
      agentId: string;
      params: UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutParams;
    },
    TContext
  > => {
    const mutationKey = ["updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut>
      >,
      {
        teamId: string;
        agentId: string;
        params: UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutParams;
      }
    > = (props) => {
      const { teamId, agentId, params } = props ?? {};

      return updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut(
        teamId,
        agentId,
        params,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut>
    >
  >;

export type UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutMutationError =
  HTTPValidationError;

/**
 * @summary Update Agent Status
 */
export const useUpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut>
      >,
      TError,
      {
        teamId: string;
        agentId: string;
        params: UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof updateAgentStatusTeamsTeamIdAgentsAgentIdStatusPut>
  >,
  TError,
  {
    teamId: string;
    agentId: string;
    params: UpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutParams;
  },
  TContext
> => {
  const mutationOptions =
    getUpdateAgentStatusTeamsTeamIdAgentsAgentIdStatusPutMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get dashboard analytics based on user role
 * @summary Get Dashboard Analytics
 */
export const getDashboardAnalyticsTeamsAnalyticsDashboardGet = (
  signal?: AbortSignal,
) => {
  return api<GetDashboardAnalyticsTeamsAnalyticsDashboardGet200>({
    url: `https://api.atuna.org/teams/analytics/dashboard`,
    method: "GET",
    signal,
  });
};

export const getGetDashboardAnalyticsTeamsAnalyticsDashboardGetQueryKey =
  () => {
    return [`https://api.atuna.org/teams/analytics/dashboard`] as const;
  };

export const getGetDashboardAnalyticsTeamsAnalyticsDashboardGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<
        ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
      >,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetDashboardAnalyticsTeamsAnalyticsDashboardGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>>
  > = ({ signal }) => getDashboardAnalyticsTeamsAnalyticsDashboardGet(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDashboardAnalyticsTeamsAnalyticsDashboardGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>>
  >;
export type GetDashboardAnalyticsTeamsAnalyticsDashboardGetQueryError = unknown;

export function useGetDashboardAnalyticsTeamsAnalyticsDashboardGet<
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDashboardAnalyticsTeamsAnalyticsDashboardGet<
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDashboardAnalyticsTeamsAnalyticsDashboardGet<
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Dashboard Analytics
 */

export function useGetDashboardAnalyticsTeamsAnalyticsDashboardGet<
  TData = Awaited<
    ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDashboardAnalyticsTeamsAnalyticsDashboardGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetDashboardAnalyticsTeamsAnalyticsDashboardGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get detailed sales analytics
 * @summary Get Sales Analytics
 */
export const getSalesAnalyticsTeamsAnalyticsSalesGet = (
  params?: GetSalesAnalyticsTeamsAnalyticsSalesGetParams,
  signal?: AbortSignal,
) => {
  return api<GetSalesAnalyticsTeamsAnalyticsSalesGet200>({
    url: `https://api.atuna.org/teams/analytics/sales`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetSalesAnalyticsTeamsAnalyticsSalesGetQueryKey = (
  params?: GetSalesAnalyticsTeamsAnalyticsSalesGetParams,
) => {
  return [
    `https://api.atuna.org/teams/analytics/sales`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSalesAnalyticsTeamsAnalyticsSalesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesAnalyticsTeamsAnalyticsSalesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSalesAnalyticsTeamsAnalyticsSalesGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>
  > = ({ signal }) => getSalesAnalyticsTeamsAnalyticsSalesGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSalesAnalyticsTeamsAnalyticsSalesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>
>;
export type GetSalesAnalyticsTeamsAnalyticsSalesGetQueryError =
  HTTPValidationError;

export function useGetSalesAnalyticsTeamsAnalyticsSalesGet<
  TData = Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetSalesAnalyticsTeamsAnalyticsSalesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
          TError,
          Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSalesAnalyticsTeamsAnalyticsSalesGet<
  TData = Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesAnalyticsTeamsAnalyticsSalesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
          TError,
          Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSalesAnalyticsTeamsAnalyticsSalesGet<
  TData = Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesAnalyticsTeamsAnalyticsSalesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Sales Analytics
 */

export function useGetSalesAnalyticsTeamsAnalyticsSalesGet<
  TData = Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesAnalyticsTeamsAnalyticsSalesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesAnalyticsTeamsAnalyticsSalesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSalesAnalyticsTeamsAnalyticsSalesGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get leads analytics
 * @summary Get Leads Analytics
 */
export const getLeadsAnalyticsTeamsAnalyticsLeadsGet = (
  params?: GetLeadsAnalyticsTeamsAnalyticsLeadsGetParams,
  signal?: AbortSignal,
) => {
  return api<GetLeadsAnalyticsTeamsAnalyticsLeadsGet200>({
    url: `https://api.atuna.org/teams/analytics/leads`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLeadsAnalyticsTeamsAnalyticsLeadsGetQueryKey = (
  params?: GetLeadsAnalyticsTeamsAnalyticsLeadsGetParams,
) => {
  return [
    `https://api.atuna.org/teams/analytics/leads`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLeadsAnalyticsTeamsAnalyticsLeadsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsAnalyticsTeamsAnalyticsLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetLeadsAnalyticsTeamsAnalyticsLeadsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>
  > = ({ signal }) => getLeadsAnalyticsTeamsAnalyticsLeadsGet(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLeadsAnalyticsTeamsAnalyticsLeadsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>
>;
export type GetLeadsAnalyticsTeamsAnalyticsLeadsGetQueryError =
  HTTPValidationError;

export function useGetLeadsAnalyticsTeamsAnalyticsLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetLeadsAnalyticsTeamsAnalyticsLeadsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
          TError,
          Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeadsAnalyticsTeamsAnalyticsLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsAnalyticsTeamsAnalyticsLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
          TError,
          Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeadsAnalyticsTeamsAnalyticsLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsAnalyticsTeamsAnalyticsLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Leads Analytics
 */

export function useGetLeadsAnalyticsTeamsAnalyticsLeadsGet<
  TData = Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLeadsAnalyticsTeamsAnalyticsLeadsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLeadsAnalyticsTeamsAnalyticsLeadsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetLeadsAnalyticsTeamsAnalyticsLeadsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get inventory management analytics
 * @summary Get Inventory Analytics
 */
export const getInventoryAnalyticsTeamsAnalyticsInventoryGet = (
  signal?: AbortSignal,
) => {
  return api<GetInventoryAnalyticsTeamsAnalyticsInventoryGet200>({
    url: `https://api.atuna.org/teams/analytics/inventory`,
    method: "GET",
    signal,
  });
};

export const getGetInventoryAnalyticsTeamsAnalyticsInventoryGetQueryKey =
  () => {
    return [`https://api.atuna.org/teams/analytics/inventory`] as const;
  };

export const getGetInventoryAnalyticsTeamsAnalyticsInventoryGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
  >,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<
        ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
      >,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetInventoryAnalyticsTeamsAnalyticsInventoryGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>>
  > = ({ signal }) => getInventoryAnalyticsTeamsAnalyticsInventoryGet(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInventoryAnalyticsTeamsAnalyticsInventoryGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>>
  >;
export type GetInventoryAnalyticsTeamsAnalyticsInventoryGetQueryError = unknown;

export function useGetInventoryAnalyticsTeamsAnalyticsInventoryGet<
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
  >,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInventoryAnalyticsTeamsAnalyticsInventoryGet<
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInventoryAnalyticsTeamsAnalyticsInventoryGet<
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Inventory Analytics
 */

export function useGetInventoryAnalyticsTeamsAnalyticsInventoryGet<
  TData = Awaited<
    ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
  >,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getInventoryAnalyticsTeamsAnalyticsInventoryGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetInventoryAnalyticsTeamsAnalyticsInventoryGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Root
 */
export const rootGet = (signal?: AbortSignal) => {
  return api<unknown>({ url: `https://api.atuna.org/`, method: "GET", signal });
};

export const getRootGetQueryKey = () => {
  return [`https://api.atuna.org/`] as const;
};

export const getRootGetQueryOptions = <
  TData = Awaited<ReturnType<typeof rootGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRootGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({
    signal,
  }) => rootGet(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type RootGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof rootGet>>
>;
export type RootGetQueryError = unknown;

export function useRootGet<
  TData = Awaited<ReturnType<typeof rootGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRootGet<
  TData = Awaited<ReturnType<typeof rootGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRootGet<
  TData = Awaited<ReturnType<typeof rootGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Root
 */

export function useRootGet<
  TData = Awaited<ReturnType<typeof rootGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRootGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Health Check
 */
export const healthCheckHealthGet = (signal?: AbortSignal) => {
  return api<unknown>({
    url: `https://api.atuna.org/health`,
    method: "GET",
    signal,
  });
};

export const getHealthCheckHealthGetQueryKey = () => {
  return [`https://api.atuna.org/health`] as const;
};

export const getHealthCheckHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthCheckHealthGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof healthCheckHealthGet>>
  > = ({ signal }) => healthCheckHealthGet(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckHealthGet>>
>;
export type HealthCheckHealthGetQueryError = unknown;

export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthCheckHealthGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get comprehensive API information and available endpoints
 * @summary Api Info
 */
export const apiInfoApiInfoGet = (signal?: AbortSignal) => {
  return api<unknown>({
    url: `https://api.atuna.org/api-info`,
    method: "GET",
    signal,
  });
};

export const getApiInfoApiInfoGetQueryKey = () => {
  return [`https://api.atuna.org/api-info`] as const;
};

export const getApiInfoApiInfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiInfoApiInfoGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof apiInfoApiInfoGet>>
  > = ({ signal }) => apiInfoApiInfoGet(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 30000,
    refetchOnWindowFocus: false,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ApiInfoApiInfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiInfoApiInfoGet>>
>;
export type ApiInfoApiInfoGetQueryError = unknown;

export function useApiInfoApiInfoGet<
  TData = Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
          TError,
          Awaited<ReturnType<typeof apiInfoApiInfoGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiInfoApiInfoGet<
  TData = Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
          TError,
          Awaited<ReturnType<typeof apiInfoApiInfoGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiInfoApiInfoGet<
  TData = Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Api Info
 */

export function useApiInfoApiInfoGet<
  TData = Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiInfoApiInfoGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getApiInfoApiInfoGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
